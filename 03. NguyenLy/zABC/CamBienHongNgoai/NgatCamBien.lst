CCS PCM C Compiler, Version 5.101, 43599               12-Nov-22 14:20

               Filename:   C:\Users\DangNgocNhan\Desktop\P3\zABC\CamBienHongNgoai\NgatCamBien.lst

               ROM used:   882 words (11%)
                           Largest free fragment is 2048
               RAM used:   51 (14%) at main() level
                           69 (19%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   315
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.3
0028:  GOTO   02B
0029:  BTFSC  0B.0
002A:  GOTO   056
002B:  BTFSS  0B.4
002C:  GOTO   02F
002D:  BTFSC  0B.1
002E:  GOTO   059
002F:  MOVLW  8C
0030:  MOVWF  04
0031:  BTFSS  00.0
0032:  GOTO   035
0033:  BTFSC  0C.0
0034:  GOTO   05C
0035:  MOVF   22,W
0036:  MOVWF  04
0037:  MOVF   23,W
0038:  MOVWF  77
0039:  MOVF   24,W
003A:  MOVWF  78
003B:  MOVF   25,W
003C:  MOVWF  79
003D:  MOVF   26,W
003E:  MOVWF  7A
003F:  MOVF   27,W
0040:  BSF    03.6
0041:  MOVWF  0D
0042:  BCF    03.6
0043:  MOVF   28,W
0044:  BSF    03.6
0045:  MOVWF  0F
0046:  BCF    03.6
0047:  MOVF   29,W
0048:  BSF    03.6
0049:  MOVWF  0C
004A:  BCF    03.6
004B:  MOVF   2A,W
004C:  BSF    03.6
004D:  MOVWF  0E
004E:  BCF    03.6
004F:  MOVF   20,W
0050:  MOVWF  0A
0051:  SWAPF  21,W
0052:  MOVWF  03
0053:  SWAPF  7F,F
0054:  SWAPF  7F,W
0055:  RETFIE
0056:  BCF    0A.3
0057:  BCF    0A.4
0058:  GOTO   067
0059:  BCF    0A.3
005A:  BCF    0A.4
005B:  GOTO   086
005C:  BCF    0A.3
005D:  BCF    0A.4
005E:  GOTO   0B8
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
005F:  BCF    0A.0
0060:  BCF    0A.1
0061:  BCF    0A.2
0062:  ADDWF  02,F
0063:  RETLW  28
0064:  RETLW  0C
0065:  RETLW  01
0066:  RETLW  06
*
00E8:  DATA D2,22
00E9:  DATA 41,22
00EA:  DATA 49,27
00EB:  DATA 47,10
00EC:  DATA 44,24
00ED:  DATA D4,18
00EE:  DATA 31,00
*
02BD:  MOVF   0B,W
02BE:  MOVWF  4D
02BF:  BCF    0B.7
02C0:  BSF    03.5
02C1:  BSF    03.6
02C2:  BSF    0C.7
02C3:  BSF    0C.0
02C4:  NOP
02C5:  NOP
02C6:  BCF    03.5
02C7:  BCF    03.6
02C8:  BTFSC  4D.7
02C9:  BSF    0B.7
02CA:  BSF    03.6
02CB:  MOVF   0C,W
02CC:  ANDLW  7F
02CD:  BTFSC  03.2
02CE:  GOTO   311
02CF:  BCF    03.6
02D0:  MOVWF  4D
02D1:  BSF    03.6
02D2:  MOVF   0D,W
02D3:  BCF    03.6
02D4:  MOVWF  4E
02D5:  BSF    03.6
02D6:  MOVF   0F,W
02D7:  BCF    03.6
02D8:  MOVWF  4F
02D9:  MOVF   4D,W
02DA:  MOVWF  50
02DB:  CALL   298
02DC:  MOVF   4E,W
02DD:  BSF    03.6
02DE:  MOVWF  0D
02DF:  BCF    03.6
02E0:  MOVF   4F,W
02E1:  BSF    03.6
02E2:  MOVWF  0F
02E3:  BCF    03.6
02E4:  MOVF   0B,W
02E5:  MOVWF  50
02E6:  BCF    0B.7
02E7:  BSF    03.5
02E8:  BSF    03.6
02E9:  BSF    0C.7
02EA:  BSF    0C.0
02EB:  NOP
02EC:  NOP
02ED:  BCF    03.5
02EE:  BCF    03.6
02EF:  BTFSC  50.7
02F0:  BSF    0B.7
02F1:  BSF    03.6
02F2:  RLF    0C,W
02F3:  RLF    0E,W
02F4:  ANDLW  7F
02F5:  BTFSC  03.2
02F6:  GOTO   311
02F7:  BCF    03.6
02F8:  MOVWF  4D
02F9:  BSF    03.6
02FA:  MOVF   0D,W
02FB:  BCF    03.6
02FC:  MOVWF  4E
02FD:  BSF    03.6
02FE:  MOVF   0F,W
02FF:  BCF    03.6
0300:  MOVWF  4F
0301:  MOVF   4D,W
0302:  MOVWF  50
0303:  CALL   298
0304:  MOVF   4E,W
0305:  BSF    03.6
0306:  MOVWF  0D
0307:  BCF    03.6
0308:  MOVF   4F,W
0309:  BSF    03.6
030A:  MOVWF  0F
030B:  INCF   0D,F
030C:  BTFSC  03.2
030D:  INCF   0F,F
030E:  BCF    03.6
030F:  GOTO   2BD
0310:  BSF    03.6
0311:  BCF    03.6
0312:  BCF    0A.3
0313:  BCF    0A.4
0314:  GOTO   353 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device *=16 adc=8
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... #FUSES HS
.................... 
.................... #use delay(crystal=20000000)
.................... #include <def_877a.h>
.................... #define W 0
.................... #define F 1
.................... 
.................... //----- Register Files------------------------------------------------------
.................... 
.................... #byte INDF =0x00
.................... #byte TMR0 =0x01 
.................... #byte PCL =0x02 
.................... #byte STATUS =0x03 
.................... #byte FSR =0x04 
.................... #byte PORTA =0x05 
.................... #byte PORTB =0x06 
.................... #byte PORTC =0x07
.................... #byte PORTD =0x08
.................... 
.................... 
.................... #byte PCLATH =0x0A 
.................... #byte PIR1 =0x0C
.................... #byte PIR2 =0x0D
.................... 
.................... #byte TMR1L =0x0E
.................... #byte TMR1H =0x0F
.................... #byte T1CON =0x10
.................... #byte TMR2 =0x11
.................... #byte T2CON =0x12
.................... 
.................... #byte SSPCON =0x14
.................... #byte CCPR1L =0x15
.................... #byte CCPR1H =0x16
.................... #byte CCP1CON =0x17
.................... #byte RCSTA =0x18
.................... #byte TXREG =0x19
.................... #byte RCREG =0x1A
.................... #byte CCPR2L =0x1B
.................... #byte CCPR2H =0x1C
.................... #byte CCP2CON =0x1D 
.................... 
.................... #byte ADRESH =0x1E
.................... #byte ADCON0 =0x1F
.................... 
.................... /* bank 1 registers */
.................... 
.................... #byte OPTION_REG =0x81
.................... 
.................... #byte TRISA =0x85
.................... #byte TRISB =0x86
.................... #byte TRISC =0x87
.................... #byte TRISD =0x88
.................... 
.................... #byte PIE1 =0x8C
.................... #byte PIE2 =0x8D
.................... #byte PCON =0x8E
.................... 
.................... #byte SSPCON2 =0x91
.................... #byte PR2 =0x92
.................... #byte SSPADD =0x93
.................... #byte SSPSTAT =0x94
.................... 
.................... #byte TXSTA =0x98
.................... #byte SPBRG =0x99
.................... 
.................... #byte ADRESL =0x9E
.................... #byte ADCON1 =0x9F
.................... 
.................... /* bank 2 registers */
.................... 
.................... #byte EEDATA =0x010C
.................... #byte EEADR =0x010D
.................... #byte EEDATH =0x010E
.................... #byte EEADRH =0x010F
.................... 
.................... /* bank 3 registers */
.................... 
.................... #byte EECON1 =0x018C
.................... #byte EECON2 =0x018D
.................... 
.................... 
.................... //----- STATUS Bits --------------------------------------------------------
.................... 
.................... // For Assembly Language - Note upper case
.................... #define IRP 7
.................... #define RP1 6
.................... #define RP0 5
.................... #define NOT_TO 4
.................... #define NOT_PD 3
.................... #define Z 2
.................... #define DC 1
.................... #define C 0
.................... 
.................... //----- INTCON Bits for c --------------------------------------------------------
.................... 
.................... #bit gie = 0x0b.7
.................... #bit eeie = 0x0b.6
.................... #bit t0ie = 0x0b.5
.................... #bit inte = 0x0b.4
.................... #bit rbie = 0x0b.3
.................... #bit t0if = 0x0b.2
.................... #bit intf = 0x0b.1
.................... #bit rbif = 0x0b.0
.................... 
.................... //---------PORTA bits------------------
.................... #bit ra5 =0x05.5
.................... #bit ra4 =0x05.4
.................... #bit ra3 =0x05.3
.................... #bit ra2 =0x05.2
.................... #bit ra1 =0x05.1
.................... #bit ra0 =0x05.0
.................... 
.................... //---------PORTB bits------------------
.................... #bit rb7 =0x06.7
.................... #bit rb6 =0x06.6
.................... #bit rb5 =0x06.5
.................... #bit rb4 =0x06.4
.................... #bit rb3 =0x06.3
.................... #bit rb2 =0x06.2
.................... #bit rb1 =0x06.1
.................... #bit rb0 =0x06.0
.................... 
.................... //---------PORTC bits------------------
.................... #bit rc7 =0x07.7
.................... #bit rc6 =0x07.6
.................... #bit rc5 =0x07.5
.................... #bit rc4 =0x07.4
.................... #bit rc3 =0x07.3
.................... #bit rc2 =0x07.2
.................... #bit rc1 =0x07.1
.................... #bit rc0 =0x07.0
.................... 
.................... #bit rd7 =0x08.7
.................... #bit rd6 =0x08.6
.................... #bit rd5 =0x08.5
.................... #bit rd4 =0x08.4
.................... #bit rd3 =0x08.3
.................... #bit rd2 =0x08.2
.................... #bit rd1 =0x08.1
.................... #bit rd0 =0x08.0
.................... 
.................... //----- PIR1 Bits ----------------------------------------------------------
.................... #bit PSPIF =0x0C.7
.................... #bit ADIF =0x0C.6
.................... #bit RCIF =0x0C.5
.................... #bit TXIF =0x0C.4
.................... #bit SSPIF =0x0C.3
.................... #bit CCP1IF =0x0C.2
.................... #bit TMR2IF =0x0C.1
.................... #bit TMR1IF =0x0C.0
.................... 
.................... //----- PIR2 Bits ----------------------------------------------------------
.................... #bit CMIF =0x0D.6
.................... #bit EEIF =0x0D.4
.................... #bit BCLIF =0x0D.3
.................... #bit CCP2IF =0x0D.0
.................... 
.................... //----- T1CON Bits ---------------------------------------------------------
.................... #bit T1CKPS1 =0x10.5
.................... #bit T1CKPS0 =0x10.4
.................... #bit T1OSCEN =0x10.3
.................... #bit T1SYNC =0x10.2
.................... #bit TMR1CS =0x10.1
.................... #bit TMR1ON =0x10.0
.................... 
.................... //----- T2CON Bits ---------------------------------------------------------
.................... #bit TOUTPS3 =0x12.6
.................... #bit TOUTPS2 =0x12.5
.................... #bit TOUTPS1 =0x12.4
.................... #bit TOUTPS0 =0x12.3
.................... #bit TMR2ON =0x12.2
.................... #bit T2CKPS1 =0x12.1
.................... #bit T2CKPS0 =0x12.0
.................... 
.................... //-------------SSPCON bits--------------------------
.................... #bit WCOL =0x14.7
.................... #bit SSPOV =0x14.6
.................... #bit SSPEN =0x14.5 
.................... #bit CKP =0x14.4
.................... #bit SSPM3 =0x14.3
.................... #bit SSPM2 =0x14.2
.................... #bit SSPM1 =0x14.1
.................... #bit SSPM0 =0x14.0
.................... 
.................... //---------------CCP1CON bits--------
.................... #bit CCP1X =0x17.5
.................... #bit CCP1Y =0x17.4
.................... #bit CCP1M3 =0x17.3
.................... #bit CCP1M2 =0x17.2
.................... #bit CCP1M1 =0x17.1
.................... #bit CCP1M0 =0x17.0
.................... 
.................... //---------------RCSTA bits-------------------
.................... 
.................... #bit SPEN =0x18.7
.................... #bit RX9 =0x18.6
.................... #bit SREN =0x18.5
.................... #bit CREN =0x18.4
.................... #bit ADDEN =0x18.3
.................... #bit FERR =0x18.2
.................... #bit OERR =0x18.1
.................... #bit RX9D =0x18.0
.................... 
.................... //-----------------------CCP2CON bits----------
.................... 
.................... #bit CCP2X =0x1D.5
.................... #bit CCP2Y =0x1D.4
.................... #bit CCP2M3 =0x1D.3
.................... #bit CCP2M2 =0x1D.2
.................... #bit CCP2M1 =0x1D.1
.................... #bit CCP2M0 =0x1D.0
.................... 
.................... //----- ADCON0 Bits --------------------------------------------------------
.................... #bit ADCS1 =0x1F.7
.................... #bit ADCS0 =0x1F.6
.................... #bit CHS2 =0x1F.5 
.................... #bit CHS1 =0x1F.4
.................... #bit CHS0 =0x1F.3
.................... #bit ADGO =0x1F.2
.................... #bit ADON =0x1F.0
.................... 
.................... //----- OPTION_reg Bits --------------------------------------------------------
.................... 
.................... #bit RBPU =0x81.7 
.................... #bit INTEDG =0x81.6 
.................... #bit T0CS =0x81.5 
.................... #bit T0SE =0x81.4 
.................... #bit PSA =0x81.3 
.................... #bit PS2 =0x81.2 
.................... #bit PS1 =0x81.1 
.................... #bit PS0 =0x81.0 
.................... 
.................... //------------------TRISA bits---------------------------
.................... 
.................... #bit TRISA5 =0x85.5
.................... #bit TRISA4 =0x85.4
.................... #bit TRISA3 =0x85.3
.................... #bit TRISA2 =0x85.2
.................... #bit TRISA1 =0x85.1 
.................... #bit TRISA0 =0x85.0
.................... 
.................... //-----------------TRISB bits-----------------------------
.................... 
.................... #bit TRISB7 =0x86.7
.................... #bit TRISB6 =0x86.6 
.................... #bit TRISB5 =0x86.5
.................... #bit TRISB4 =0x86.4 
.................... #bit TRISB3 =0x86.3
.................... #bit TRISB2 =0x86.2
.................... #bit TRISB1 =0x86.1 
.................... #bit TRISB0 =0x86.0 
.................... 
.................... //----------------TRISC bits-------------------
.................... 
.................... #bit TRISC7 =0x87.7
.................... #bit TRISC6 =0x87.6
.................... #bit TRISC5 =0x87.5 
.................... #bit TRISC4 =0x87.4
.................... #bit TRISC3 =0x87.3
.................... #bit TRISC2 =0x87.2 
.................... #bit TRISC1 =0x87.1
.................... #bit TRISC0 =0x87.0
.................... 
.................... #bit TRISD7 =0x88.7
.................... #bit TRISD6 =0x88.6
.................... #bit TRISD5 =0x88.5 
.................... #bit TRISD4 =0x88.4
.................... #bit TRISD3 =0x88.3
.................... #bit TRISD2 =0x88.2 
.................... #bit TRISD1 =0x88.1
.................... #bit TRISD0 =0x88.0
.................... 
.................... //----- PIE1 Bits ----------------------------------------------------------
.................... 
.................... #bit PSPIE =0x8C.7
.................... #bit ADIE =0x8C.6
.................... #bit RCIE =0x8C.5 
.................... #bit TXIE =0x8C.4 
.................... #bit SSPIE =0x8C.3
.................... #bit CCP1IE =0x8C.2 
.................... #bit TMR2IE =0x8C.1
.................... #bit TMR1IE =0x8C.0
.................... 
.................... //----- PIE2 Bits -----------------------------------------------------
.................... 
.................... #bit CMIE =0x8D.6
.................... #bit EEIE =0x8D.4
.................... #bit BCLIE =0x8D.3
.................... #bit CCP2IE =0x8D.0
.................... 
.................... //----- PCON Bits ----------------------------------------------------------
.................... 
.................... #bit POR =0x8E.1
.................... #bit BOD =0x8E.0
.................... 
.................... //-----------SSPCON2 bits---------------------------------------------
.................... 
.................... #bit GCEN =0x91.7
.................... #bit ACKSTAT =0x91.6
.................... #bit ACKDT =0x91.5 
.................... #bit ACKEN =0x91.4
.................... #bit RCEN =0x91.3 
.................... #bit PEN =0x91.2
.................... #bit RSEN =0x91.1
.................... #bit SEN =0x91.0 
.................... 
.................... //---------------------SSPSTAT bits------------------------
.................... 
.................... #bit STAT_SMP =0x94.7
.................... #bit STAT_CKE =0x94.6
.................... #bit STAT_DA =0x94.5
.................... #bit STAT_P =0x94.4
.................... #bit STAT_S =0x94.3
.................... #bit STAT_RW =0x94.2
.................... #bit STAT_UA =0x94.1
.................... #bit STAT_BF =0x94.0
.................... 
.................... //----------------TXSTA bits-----------------
.................... 
.................... #bit CSRC =0x98.7
.................... #bit TX9 =0x98.6
.................... #bit TXEN =0x98.5 
.................... #bit SYNC =0x98.4
.................... #bit BRGH =0x98.2
.................... #bit TRMT =0x98.1
.................... #bit TX9D =0x98.0
.................... 
.................... //--------------ADCON1 bits---------------
.................... 
.................... #bit ADFM =0x9F.7
.................... #bit ADCS2 =0x9F.6
.................... #bit PCFG3 =0x9F.3
.................... #bit PCFG2 =0x9F.2
.................... #bit PCFG1 =0x9F.1 
.................... #bit PCFG0 =0x9F.0
.................... 
.................... //-----------EECON1 bits----------
.................... 
.................... #bit EEPGD =0x018C.7
.................... #bit WRERR =0x018C.3
.................... #bit WREN =0x018C.2 
.................... #bit WR =0x018C.1
.................... #bit RD =0x018C.0
.................... 
.................... //!const unsigned char Code7Seg_duong[] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
.................... //!const unsigned char Code7Seg_am[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0xFF};
.................... 
.................... 
.................... #include "DHT11.c"
.................... #define _DHT11_H_
.................... //!#include <def_877a.h>
.................... #use delay(crystal=20M)
*
00EF:  MOVLW  51
00F0:  MOVWF  04
00F1:  BCF    03.7
00F2:  MOVF   00,W
00F3:  BTFSC  03.2
00F4:  GOTO   102
00F5:  MOVLW  06
00F6:  MOVWF  78
00F7:  CLRF   77
00F8:  DECFSZ 77,F
00F9:  GOTO   0F8
00FA:  DECFSZ 78,F
00FB:  GOTO   0F7
00FC:  MOVLW  7B
00FD:  MOVWF  77
00FE:  DECFSZ 77,F
00FF:  GOTO   0FE
0100:  DECFSZ 00,F
0101:  GOTO   0F5
0102:  RETURN
.................... 
.................... //!#bit ra5 =0x05.5     #bit rb7 =0x06.7     #bit rc7 =0x07.7     #bit rd7 =0x08.7
.................... //!#bit ra4 =0x05.4     #bit rb6 =0x06.6     #bit rc6 =0x07.6     #bit rd6 =0x08.6
.................... //!#bit ra3 =0x05.3     #bit rb5 =0x06.5     #bit rc5 =0x07.5     #bit rd5 =0x08.5
.................... //!#bit ra2 =0x05.2     #bit rb4 =0x06.4     #bit rc4 =0x07.4     #bit rd4 =0x08.4
.................... //!#bit ra1 =0x05.1     #bit rb3 =0x06.3     #bit rc3 =0x07.3     #bit rd3 =0x08.3
.................... //!#bit ra0 =0x05.0     #bit rb2 =0x06.2     #bit rc2 =0x07.2     #bit rd2 =0x08.2
.................... //!                     #bit rb1 =0x06.1     #bit rc1 =0x07.1     #bit rd1 =0x08.1
.................... //!                     #bit rb0 =0x06.0     #bit rc0 =0x07.0     #bit rd0 =0x08.0
.................... //!
.................... //----------------TRIS bits-------------------
.................... //!#bit TRISA5 =0x85.5     #bit TRISB7 =0x86.7     #bit TRISC7 =0x87.7     #bit TRISD7 =0x88.7
.................... //!#bit TRISA4 =0x85.4     #bit TRISB6 =0x86.6     #bit TRISC6 =0x87.6     #bit TRISD6 =0x88.6
.................... //!#bit TRISA3 =0x85.3     #bit TRISB5 =0x86.5     #bit TRISC5 =0x87.5     #bit TRISD5 =0x88.5
.................... //!#bit TRISA2 =0x85.2     #bit TRISB4 =0x86.4     #bit TRISC4 =0x87.4     #bit TRISD4 =0x88.4
.................... //!#bit TRISA1 =0x85.1     #bit TRISB3 =0x86.3     #bit TRISC3 =0x87.3     #bit TRISD3 =0x88.3
.................... //!#bit TRISA0 =0x85.0     #bit TRISB2 =0x86.2     #bit TRISC2 =0x87.2     #bit TRISD2 =0x88.2 
.................... //!                        #bit TRISB2 =0x86.2     #bit TRISC2 =0x87.2     #bit TRISD2 =0x88.2 
.................... //!                        #bit TRISB0 =0x86.0     #bit TRISC0 =0x87.0     #bit TRISD0 =0x88.0
.................... 
.................... #BIT DHT_DATA_OUT = 0x05.0
.................... #BIT DHT_DATA_IN = 0x05.0 
.................... #BIT DHT_DDR_DATA = 0x85.0
.................... 
.................... #define DHT_ER 0
.................... #define DHT_OK 1
.................... 
.................... #define DDROUT 0
.................... #define DDRIN 1
.................... 
.................... unsigned int8 DHT_GetTemHumi (unsigned int8 &tem1, , &tem2, unsigned int8 &humil, &humi2);
.................... 
.................... unsigned int8 DHT_GetTemHumi (unsigned int8 &tem1,&tem2, unsigned int8 &humi1, &humi2)
.................... { 
....................    unsigned int8 buffer[5]={0,0,0,0,0};
....................    unsigned int8 ii,i,checksum;
....................    DHT_DDR_DATA=DDROUT;    // set la cong ra
....................    DHT_DATA_OUT=1;
....................    delay_us(60);
....................    DHT_DATA_OUT=0;
....................    delay_ms(25); // it nhat 18ms
....................    DHT_DATA_OUT=1;
....................    DHT_DDR_DATA=DDRIN;//set la cong vao
....................    
....................    delay_us(60);
....................    if(DHT_DATA_IN) return DHT_ER;
....................    else while(!(DHT_DATA_IN)); //Doi DaTa len 1
....................    delay_us(60);//cho 60us
....................    if(!DHT_DATA_IN) return DHT_ER;
....................    else while((DHT_DATA_IN)); //Doi Data ve 0
....................     //Bat dau doc du lieu
....................     for(i=0;i<5;i++) 
....................     {
....................       for(ii=0;ii<8;ii++) 
....................       {
....................          while((!DHT_DATA_IN));              // Doi Data len 1
....................          delay_us(50);
....................          if(DHT_DATA_IN)
....................          {
....................             buffer[i]|=(1<<(7-ii));
....................             while((DHT_DATA_IN));
....................          }
....................       }
....................     }
....................    checksum=buffer[0]+buffer[1]+buffer[2]+buffer[3]; 
....................    if((checksum) !=buffer[4])return DHT_ER; 
....................    tem1 = buffer[2];//gia tri phan nguyen 
....................    tem2 = buffer[3];//gia tri phan thap phan
....................    humi1 = buffer[0];//gia tri phan nguyen 
....................    humi2 = buffer[1];//gia tri phan thap phan
....................    return DHT_OK;
.................... }
.................... 
.................... //!
.................... //!
.................... //!#include <def_877a.h>
.................... //!#bit ra0 =0x05.0
.................... //!#bit TRISA0 =0x85.0
.................... //!#device *=16 adc=8
.................... //!#define  Data_Pin       Pin_D4                      // ket noi voi chan RD0
.................... //!#define  Data_Pin_TRIS  SET_TRIS_D                // dieu khien chan data la output hay input 
.................... //!
.................... //!int8 Data_DHT11[5];
.................... //!
.................... //!int1 DHT11_Start(){    // start
.................... //!   Data_Pin_TRIS(0);   // MCU output
.................... //!   Output_low(Data_Pin);        // MCU keo chan data xuong muc thap >18 ms
.................... //!   delay_ms(25);
.................... //!   Output_high(Data_Pin);        // MCU keo chan data len muc cao 
.................... //!   Data_Pin_TRIS(0xff);   // MCU input doi tin hieu tra ve cua DHT11 khoang 20 - 40 us
.................... //!   delay_us(40);
.................... //!   if(input(Data_Pin) == 0){    //DHT11 keo chan data xuong thap 80 us sau do keo len cao 80 us --> xac nhan ket noi
.................... //!      delay_us(80);
.................... //!      if(input(Data_Pin) == 1){
.................... //!         delay_us(80);
.................... //!         return 1;         // xac nhan ket noi thanh cong
.................... //!      }
.................... //!   }
.................... //!}
.................... //! 
.................... //!
.................... //!int1 ReadData_DHT11(){       // doc data cua DHT11 tra ve
.................... //!    for(int i = 0; i < 5; i++){        // data: 5 byte
.................... //!      for(int j = 0; j < 8; j++){      // 1 byte 8 bit   tong 40 bit
.................... //!         // data
.................... //!         while(input(Data_Pin) == 0){};      // chay het 50us muc thap
.................... //!         delay_us(30);              //  hon 26-28us van la muc cao --> DHT11 chuyen di muc 1
.................... //!         if(input(Data_Pin) == 1){  
.................... //!               Data_DHT11[i] = Data_DHT11[i]<<1 | 1;
.................... //!               while(input(Data_Pin) == 1){} // chay het 70us muc cao
.................... //!         }
.................... //!         else{                   // tra ve bit 0
.................... //!            Data_DHT11[i] = Data_DHT11[i]<<1 | 0;
.................... //!         }
.................... //!      }   
.................... //!    }
.................... //!    // ------- kiem tra byte 5 = sum(byte 1 + 2 + 3 + 4) --> chuyen data thanh cong. nguoc lai 
.................... //!    if(Data_DHT11[4] == (Data_DHT11[0] + Data_DHT11[1] + Data_DHT11[2] + Data_DHT11[3])){
.................... //!      return 1;
.................... //!    }
.................... //!}
.................... //!
.................... //!
.................... //!
.................... //!
.................... //!void HienThi_Data_DHT11(){
.................... //!    //------------------in ket qua-----------------------------------------------
.................... //!    //in nhiet do
.................... //! 
.................... //!    
.................... //!    lcd_init(0x4E,16,2);
.................... //!    printf(lcd_putc, "Nhiet do = "); 
.................... //!    for(int i = 13; i > 11; i--){
.................... //!       lcd_gotoxy(i,1);       //hien thi hang don vi truoc >hang chuc
.................... //!       printf(lcd_putc, "%d", Data_DHT11[2] % 10 + 48); 
.................... //!       Data_DHT11[2]=Data_DHT11[2] / 10;
.................... //!    }
.................... //!    //in do am
.................... //!    lcd_gotoxy(1,2);
.................... //!    printf(lcd_putc, "Do am = ");  
.................... //!    for(int i = 13; i > 11; i--){ 
.................... //!       lcd_gotoxy(i,2);   
.................... //!       printf(lcd_putc, "%d", Data_DHT11[0] % 10 + 48); //hien thi hang don vi truoc >hang chuc  //doi ra so thap phan +48 
.................... //!       Data_DHT11[0]=Data_DHT11[0] / 10;
.................... //!    }
.................... //!      //hien thi don vi nhiet do va do am 
.................... //!    LCD_Gotoxy(14,1);   
.................... //!    LCD_putc(223);
.................... //!    LCD_putc('C');
.................... //!    LCD_Gotoxy(14,2);   
.................... //!    LCD_putc('%');
.................... //!}
.................... 
.................... 
.................... 
.................... #use i2c(Master,Fast=400000, sda=PIN_C4, scl=PIN_C3,force_sw)
0103:  MOVLW  08
0104:  MOVWF  78
0105:  NOP
0106:  BCF    07.3
0107:  BCF    2B.3
0108:  MOVF   2B,W
0109:  BSF    03.5
010A:  MOVWF  07
010B:  NOP
010C:  BCF    03.5
010D:  RLF    5E,F
010E:  BCF    07.4
010F:  BTFSS  03.0
0110:  GOTO   117
0111:  BSF    2B.4
0112:  MOVF   2B,W
0113:  BSF    03.5
0114:  MOVWF  07
0115:  GOTO   11B
0116:  BCF    03.5
0117:  BCF    2B.4
0118:  MOVF   2B,W
0119:  BSF    03.5
011A:  MOVWF  07
011B:  NOP
011C:  BCF    03.5
011D:  BSF    2B.3
011E:  MOVF   2B,W
011F:  BSF    03.5
0120:  MOVWF  07
0121:  BCF    03.5
0122:  BTFSS  07.3
0123:  GOTO   122
0124:  DECFSZ 78,F
0125:  GOTO   105
0126:  NOP
0127:  BCF    07.3
0128:  BCF    2B.3
0129:  MOVF   2B,W
012A:  BSF    03.5
012B:  MOVWF  07
012C:  NOP
012D:  BCF    03.5
012E:  BSF    2B.4
012F:  MOVF   2B,W
0130:  BSF    03.5
0131:  MOVWF  07
0132:  NOP
0133:  NOP
0134:  BCF    03.5
0135:  BSF    2B.3
0136:  MOVF   2B,W
0137:  BSF    03.5
0138:  MOVWF  07
0139:  BCF    03.5
013A:  BTFSS  07.3
013B:  GOTO   13A
013C:  CLRF   78
013D:  NOP
013E:  BTFSC  07.4
013F:  BSF    78.0
0140:  BCF    07.3
0141:  BCF    2B.3
0142:  MOVF   2B,W
0143:  BSF    03.5
0144:  MOVWF  07
0145:  BCF    03.5
0146:  BCF    07.4
0147:  BCF    2B.4
0148:  MOVF   2B,W
0149:  BSF    03.5
014A:  MOVWF  07
014B:  BCF    03.5
014C:  RETURN
.................... #include "i2c_Flex_LCD.c"
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 rows by 1...20 columns 
.................... //                using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.1 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 
.................... //                "20X4_LCD_I2C_DRIVER.h" from Pumrin S. and "lcd4_i2c.c" from XP8100 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD display 
.................... //     \n Set write position on next lcd line 
.................... //     \b LCD backspace 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... // lcd_backlight_led(ON)/lcd_backlight_led(OFF) = Turn ON/OFF LCD Backlight LED 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Comment   : Control of a compatible LCD (1...4 rows by 1...4 columns) from 
.................... //              a bus I2C with an EXPANDER of I/O with connection I2C. 
.................... //              The tests of these routines have been programmed using the IC 
.................... //              Phillips PCF8574T. I've used 4 bits mode programming. 
.................... //              The 8 bits mode programming is possible if you use 2 x PCF8574T. 
.................... //              RW Pin is not being used. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW    (Not used!) 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... byte LCD_ADDR ;//             0x4E        //I2C slave address for LCD module 
.................... byte lcd_total_rows ;//       2           //Number of rows: 1,2,3 or 4 
.................... byte lcd_total_columns ;//    16          //Number of columns: 1...20   
.................... 
.................... #define RS                    0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW                    0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define ENABLE                0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define LCD_BACKLIGHT         0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
.................... 
.................... #define addr_row_one          0x00        //LCD RAM address for row 1 
.................... #define addr_row_two          0x40        //LCD RAM address for row 2 
.................... #define addr_row_three        0x14        //LCD RAM address for row 3 
.................... #define addr_row_four         0x54        //LCD RAM address for row 4 
.................... 
.................... #define ON                    1 
.................... #define OFF                   0 
.................... #define NOT                   ~ 
.................... #define data_shifted          data<<4 
.................... int8 new_row_request=1, BACKLIGHT_LED=LCD_BACKLIGHT; 
.................... 
.................... void lcd_backlight_led(byte bl) 
.................... {  
....................       If (bl) BACKLIGHT_LED=LCD_BACKLIGHT; else BACKLIGHT_LED=OFF; 
*
0259:  MOVF   4D,F
025A:  BTFSC  03.2
025B:  GOTO   25F
025C:  MOVLW  08
025D:  MOVWF  30
025E:  GOTO   260
025F:  CLRF   30
0260:  RETURN
.................... } 
.................... 
.................... void i2c_send_nibble(byte data, byte type) 
.................... {    
....................    switch (type) 
*
014D:  MOVF   5C,W
014E:  XORLW  00
014F:  BTFSC  03.2
0150:  GOTO   155
0151:  XORLW  01
0152:  BTFSC  03.2
0153:  GOTO   178
0154:  GOTO   19C
....................    {      
....................       case 0 :      
....................       i2c_write(data_shifted | BACKLIGHT_LED); 
0155:  SWAPF  5B,W
0156:  MOVWF  77
0157:  MOVLW  F0
0158:  ANDWF  77,F
0159:  MOVF   77,W
015A:  IORWF  30,W
015B:  MOVWF  5D
015C:  MOVWF  5E
015D:  CALL   103
....................       delay_cycles(1); 
015E:  NOP
....................       i2c_write(data_shifted | ENABLE | BACKLIGHT_LED ); 
015F:  SWAPF  5B,W
0160:  MOVWF  77
0161:  MOVLW  F0
0162:  ANDWF  77,F
0163:  MOVF   77,W
0164:  IORLW  04
0165:  IORWF  30,W
0166:  MOVWF  5D
0167:  MOVWF  5E
0168:  CALL   103
....................       delay_us(2); 
0169:  MOVLW  03
016A:  MOVWF  77
016B:  DECFSZ 77,F
016C:  GOTO   16B
....................       i2c_write(data_shifted & NOT ENABLE | BACKLIGHT_LED); 
016D:  SWAPF  5B,W
016E:  MOVWF  77
016F:  MOVLW  F0
0170:  ANDWF  77,F
0171:  MOVF   77,W
0172:  ANDLW  FB
0173:  IORWF  30,W
0174:  MOVWF  5D
0175:  MOVWF  5E
0176:  CALL   103
....................       break; 
0177:  GOTO   19C
....................       
....................       case 1 : 
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED); 
0178:  SWAPF  5B,W
0179:  MOVWF  77
017A:  MOVLW  F0
017B:  ANDWF  77,F
017C:  MOVF   77,W
017D:  IORLW  01
017E:  IORWF  30,W
017F:  MOVWF  5D
0180:  MOVWF  5E
0181:  CALL   103
....................       delay_cycles(1); 
0182:  NOP
....................       i2c_write(data_shifted | RS | ENABLE | BACKLIGHT_LED ); 
0183:  SWAPF  5B,W
0184:  MOVWF  77
0185:  MOVLW  F0
0186:  ANDWF  77,F
0187:  MOVF   77,W
0188:  IORLW  01
0189:  IORLW  04
018A:  IORWF  30,W
018B:  MOVWF  5D
018C:  MOVWF  5E
018D:  CALL   103
....................       delay_us(2); 
018E:  MOVLW  03
018F:  MOVWF  77
0190:  DECFSZ 77,F
0191:  GOTO   190
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED); 
0192:  SWAPF  5B,W
0193:  MOVWF  77
0194:  MOVLW  F0
0195:  ANDWF  77,F
0196:  MOVF   77,W
0197:  IORLW  01
0198:  IORWF  30,W
0199:  MOVWF  5D
019A:  MOVWF  5E
019B:  CALL   103
....................       break; 
....................    } 
019C:  RETURN
.................... } 
....................     
.................... void lcd_send_byte(byte data, byte type) 
....................    { 
....................         i2c_start(); 
019D:  BSF    2B.4
019E:  MOVF   2B,W
019F:  BSF    03.5
01A0:  MOVWF  07
01A1:  NOP
01A2:  BCF    03.5
01A3:  BSF    2B.3
01A4:  MOVF   2B,W
01A5:  BSF    03.5
01A6:  MOVWF  07
01A7:  NOP
01A8:  BCF    03.5
01A9:  BCF    07.4
01AA:  BCF    2B.4
01AB:  MOVF   2B,W
01AC:  BSF    03.5
01AD:  MOVWF  07
01AE:  NOP
01AF:  BCF    03.5
01B0:  BCF    07.3
01B1:  BCF    2B.3
01B2:  MOVF   2B,W
01B3:  BSF    03.5
01B4:  MOVWF  07
....................         i2c_write(LCD_ADDR); 
01B5:  BCF    03.5
01B6:  MOVF   2C,W
01B7:  MOVWF  5E
01B8:  CALL   103
....................         i2c_send_nibble(data >> 4 , type); 
01B9:  SWAPF  58,W
01BA:  MOVWF  5A
01BB:  MOVLW  0F
01BC:  ANDWF  5A,F
01BD:  MOVF   5A,W
01BE:  MOVWF  5B
01BF:  MOVF   59,W
01C0:  MOVWF  5C
01C1:  CALL   14D
....................         i2c_send_nibble(data & 0xf , type); 
01C2:  MOVF   58,W
01C3:  ANDLW  0F
01C4:  MOVWF  5A
01C5:  MOVWF  5B
01C6:  MOVF   59,W
01C7:  MOVWF  5C
01C8:  CALL   14D
....................         i2c_stop();        
01C9:  BCF    2B.4
01CA:  MOVF   2B,W
01CB:  BSF    03.5
01CC:  MOVWF  07
01CD:  NOP
01CE:  BCF    03.5
01CF:  BSF    2B.3
01D0:  MOVF   2B,W
01D1:  BSF    03.5
01D2:  MOVWF  07
01D3:  BCF    03.5
01D4:  BTFSS  07.3
01D5:  GOTO   1D4
01D6:  NOP
01D7:  GOTO   1D8
01D8:  NOP
01D9:  BSF    2B.4
01DA:  MOVF   2B,W
01DB:  BSF    03.5
01DC:  MOVWF  07
01DD:  NOP
01DE:  BCF    03.5
01DF:  RETURN
....................    } 
.................... 
.................... void lcd_clear() 
.................... {  
....................         lcd_send_byte(0x01,0); 
01E0:  MOVLW  01
01E1:  MOVWF  58
01E2:  CLRF   59
01E3:  CALL   19D
....................         delay_ms(2); 
01E4:  MOVLW  02
01E5:  MOVWF  51
01E6:  CALL   0EF
....................         new_row_request=1; 
01E7:  MOVLW  01
01E8:  MOVWF  2F
01E9:  RETURN
.................... } 
.................... 
.................... void lcd_init(byte ADDR, byte col, byte row) 
.................... { 
....................    byte i;
....................    byte CONST lcd_type=2;  // 0=5x7, 1=5x10, 2=2 lines 
....................    byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; // These bytes need to be sent to the LCD to start it up.
....................    
....................    LCD_ADDR =ADDR;//             0x4E        //I2C slave address for LCD module 
01EA:  MOVF   4D,W
01EB:  MOVWF  2C
....................    lcd_total_rows =row;//       2           //Number of rows: 1,2,3 or 4 
01EC:  MOVF   4F,W
01ED:  MOVWF  2D
....................    lcd_total_columns= col ;
01EE:  MOVF   4E,W
01EF:  MOVWF  2E
....................    disable_interrupts(GLOBAL); 
01F0:  BCF    0B.6
01F1:  BCF    0B.7
01F2:  BTFSC  0B.7
01F3:  GOTO   1F1
....................    delay_ms(50); //LCD power up delay 
01F4:  MOVLW  32
01F5:  MOVWF  51
01F6:  CALL   0EF
....................     
....................    i2c_start(); 
01F7:  BSF    2B.4
01F8:  MOVF   2B,W
01F9:  BSF    03.5
01FA:  MOVWF  07
01FB:  NOP
01FC:  BCF    03.5
01FD:  BSF    2B.3
01FE:  MOVF   2B,W
01FF:  BSF    03.5
0200:  MOVWF  07
0201:  NOP
0202:  BCF    03.5
0203:  BCF    07.4
0204:  BCF    2B.4
0205:  MOVF   2B,W
0206:  BSF    03.5
0207:  MOVWF  07
0208:  NOP
0209:  BCF    03.5
020A:  BCF    07.3
020B:  BCF    2B.3
020C:  MOVF   2B,W
020D:  BSF    03.5
020E:  MOVWF  07
....................    i2c_write(LCD_ADDR); 
020F:  BCF    03.5
0210:  MOVF   2C,W
0211:  MOVWF  5E
0212:  CALL   103
....................       i2c_send_nibble(0x00,0); 
0213:  CLRF   5B
0214:  CLRF   5C
0215:  CALL   14D
....................       delay_ms(15); 
0216:  MOVLW  0F
0217:  MOVWF  51
0218:  CALL   0EF
....................     
....................    for (i=1;i<=3;++i)    
0219:  MOVLW  01
021A:  MOVWF  50
021B:  MOVF   50,W
021C:  SUBLW  03
021D:  BTFSS  03.0
021E:  GOTO   228
....................    { 
....................       i2c_send_nibble(0x03,0); 
021F:  MOVLW  03
0220:  MOVWF  5B
0221:  CLRF   5C
0222:  CALL   14D
....................       delay_ms(5); 
0223:  MOVLW  05
0224:  MOVWF  51
0225:  CALL   0EF
0226:  INCF   50,F
0227:  GOTO   21B
....................    }    
....................       i2c_send_nibble(0x02,0); 
0228:  MOVLW  02
0229:  MOVWF  5B
022A:  CLRF   5C
022B:  CALL   14D
....................       delay_ms(5); 
022C:  MOVLW  05
022D:  MOVWF  51
022E:  CALL   0EF
....................    i2c_stop(); 
022F:  BCF    2B.4
0230:  MOVF   2B,W
0231:  BSF    03.5
0232:  MOVWF  07
0233:  NOP
0234:  BCF    03.5
0235:  BSF    2B.3
0236:  MOVF   2B,W
0237:  BSF    03.5
0238:  MOVWF  07
0239:  BCF    03.5
023A:  BTFSS  07.3
023B:  GOTO   23A
023C:  NOP
023D:  GOTO   23E
023E:  NOP
023F:  BSF    2B.4
0240:  MOVF   2B,W
0241:  BSF    03.5
0242:  MOVWF  07
0243:  NOP
....................     
....................    for (i=0;i<=3;++i) { 
0244:  BCF    03.5
0245:  CLRF   50
0246:  MOVF   50,W
0247:  SUBLW  03
0248:  BTFSS  03.0
0249:  GOTO   255
....................    lcd_send_byte(LCD_INIT_STRING[i],0); 
024A:  MOVF   50,W
024B:  CALL   05F
024C:  MOVWF  51
024D:  MOVWF  58
024E:  CLRF   59
024F:  CALL   19D
....................    delay_ms(5); 
0250:  MOVLW  05
0251:  MOVWF  51
0252:  CALL   0EF
0253:  INCF   50,F
0254:  GOTO   246
....................    } 
....................    lcd_clear();  //Clear Display 
0255:  CALL   1E0
....................    enable_interrupts(GLOBAL); 
0256:  MOVLW  C0
0257:  IORWF  0B,F
0258:  RETURN
.................... } 
.................... 
.................... void lcd_gotoxy( byte x, byte y) 
.................... { 
.................... byte row,column,row_addr,lcd_address; 
.................... static char data; 
*
0329:  BCF    03.5
032A:  CLRF   31
.................... 
....................    if (y>lcd_total_rows) row=lcd_total_rows; else row=y; 
*
0261:  MOVF   52,W
0262:  SUBWF  2D,W
0263:  BTFSC  03.0
0264:  GOTO   268
0265:  MOVF   2D,W
0266:  MOVWF  53
0267:  GOTO   26A
0268:  MOVF   52,W
0269:  MOVWF  53
....................   
....................    switch(row) 
026A:  MOVF   53,W
026B:  XORLW  01
026C:  BTFSC  03.2
026D:  GOTO   278
026E:  XORLW  03
026F:  BTFSC  03.2
0270:  GOTO   27A
0271:  XORLW  01
0272:  BTFSC  03.2
0273:  GOTO   27D
0274:  XORLW  07
0275:  BTFSC  03.2
0276:  GOTO   280
0277:  GOTO   283
....................    { 
....................       case 1:  row_addr=addr_row_one;     break; 
0278:  CLRF   55
0279:  GOTO   284
....................       case 2:  row_addr=addr_row_two;     break; 
027A:  MOVLW  40
027B:  MOVWF  55
027C:  GOTO   284
....................       case 3:  row_addr=addr_row_three;   break; 
027D:  MOVLW  14
027E:  MOVWF  55
027F:  GOTO   284
....................       case 4:  row_addr=addr_row_four;    break; 
0280:  MOVLW  54
0281:  MOVWF  55
0282:  GOTO   284
....................       default: row_addr=addr_row_one;     break;  
0283:  CLRF   55
....................    }  
....................     
....................    if (x>lcd_total_columns) column=lcd_total_columns; else column=x;  
0284:  MOVF   51,W
0285:  SUBWF  2E,W
0286:  BTFSC  03.0
0287:  GOTO   28B
0288:  MOVF   2E,W
0289:  MOVWF  54
028A:  GOTO   28D
028B:  MOVF   51,W
028C:  MOVWF  54
....................    lcd_address=(row_addr+(column-1)); 
028D:  MOVLW  01
028E:  SUBWF  54,W
028F:  ADDWF  55,W
0290:  MOVWF  56
....................    lcd_send_byte(0x80|lcd_address,0); 
0291:  MOVF   56,W
0292:  IORLW  80
0293:  MOVWF  57
0294:  MOVWF  58
0295:  CLRF   59
0296:  CALL   19D
0297:  RETURN
.................... } 
.................... 
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... {    
....................   switch(in_data) 
0298:  MOVF   50,W
0299:  XORLW  0C
029A:  BTFSC  03.2
029B:  GOTO   2A3
029C:  XORLW  06
029D:  BTFSC  03.2
029E:  GOTO   2A5
029F:  XORLW  02
02A0:  BTFSC  03.2
02A1:  GOTO   2B2
02A2:  GOTO   2B7
....................    {  
....................      case '\f': lcd_clear();                       break;                
02A3:  CALL   1E0
02A4:  GOTO   2BC
....................       
....................      case '\n': 
....................      new_row_request++; 
02A5:  INCF   2F,F
....................      if (new_row_request>lcd_total_rows) new_row_request=1; 
02A6:  MOVF   2F,W
02A7:  SUBWF  2D,W
02A8:  BTFSC  03.0
02A9:  GOTO   2AC
02AA:  MOVLW  01
02AB:  MOVWF  2F
....................      lcd_gotoxy(1, new_row_request); 
02AC:  MOVLW  01
02AD:  MOVWF  51
02AE:  MOVF   2F,W
02AF:  MOVWF  52
02B0:  CALL   261
....................      break; 
02B1:  GOTO   2BC
....................                   
....................      case '\b': lcd_send_byte(0x10,0);             break; 
02B2:  MOVLW  10
02B3:  MOVWF  58
02B4:  CLRF   59
02B5:  CALL   19D
02B6:  GOTO   2BC
....................         
....................      default: lcd_send_byte(in_data,1);            break;      
02B7:  MOVF   50,W
02B8:  MOVWF  58
02B9:  MOVLW  01
02BA:  MOVWF  59
02BB:  CALL   19D
....................       
....................    } 
02BC:  RETURN
.................... } 
.................... 
.................... 
.................... unsigned int8 dh_nhiet_do,dh_nhiet_do2,dh_do_am,dh_do_am2;
.................... unsigned int8 str[20];
.................... 
.................... #INT_RB
.................... void portb_interrupt(void)
.................... {
....................      CLEAR_INTERRUPT(INT_RB);    //clear flag interrupt
*
0067:  MOVF   06,W
0068:  NOP
0069:  BCF    0B.0
....................      if(input_state(PIN_B4)==1){
006A:  BTFSS  06.4
006B:  GOTO   070
....................          output_high(PIN_D0);
006C:  BSF    03.5
006D:  BCF    08.0
006E:  BCF    03.5
006F:  BSF    08.0
....................      }
....................      if(input_state(PIN_B5)==1) {
0070:  BTFSS  06.5
0071:  GOTO   076
....................          output_high(PIN_D1);
0072:  BSF    03.5
0073:  BCF    08.1
0074:  BCF    03.5
0075:  BSF    08.1
....................      }
....................      if(input_state(PIN_B6)==1)  {
0076:  BTFSS  06.6
0077:  GOTO   07C
....................          output_high(PIN_D2);
0078:  BSF    03.5
0079:  BCF    08.2
007A:  BCF    03.5
007B:  BSF    08.2
....................      }
....................      if(input_state(PIN_B7)==1) {
007C:  BTFSS  06.7
007D:  GOTO   082
....................          output_high(PIN_D6);
007E:  BSF    03.5
007F:  BCF    08.6
0080:  BCF    03.5
0081:  BSF    08.6
....................      }
.................... }
.................... 
.................... 
0082:  BCF    0B.0
0083:  BCF    0A.3
0084:  BCF    0A.4
0085:  GOTO   035
.................... #int_ext // giup vao ngat
.................... void Ngat_int_ext()
.................... {
.................... //!    CLEAR_INTERRUPT(int_ext);
....................     if(input_state(PIN_B1)==0 && dh_do_am >= 80){ 
0086:  BTFSC  06.1
0087:  GOTO   091
0088:  MOVF   34,W
0089:  SUBLW  4F
008A:  BTFSC  03.0
008B:  GOTO   091
....................         output_toggle(PIN_D4);
008C:  BSF    03.5
008D:  BCF    08.4
008E:  MOVLW  10
008F:  BCF    03.5
0090:  XORWF  08,F
....................     }
....................     if(input_state(PIN_B2)==0){
0091:  BTFSC  06.2
0092:  GOTO   098
....................         output_toggle(PIN_D4);
0093:  BSF    03.5
0094:  BCF    08.4
0095:  MOVLW  10
0096:  BCF    03.5
0097:  XORWF  08,F
....................     }
....................     if(input_state(PIN_A1)==0){
0098:  BTFSC  05.1
0099:  GOTO   09F
....................         output_toggle(PIN_D4);
009A:  BSF    03.5
009B:  BCF    08.4
009C:  MOVLW  10
009D:  BCF    03.5
009E:  XORWF  08,F
....................     }
....................     if(input_state(PIN_A2)==0){
009F:  BTFSC  05.2
00A0:  GOTO   0A6
....................         output_toggle(PIN_D4);
00A1:  BSF    03.5
00A2:  BCF    08.4
00A3:  MOVLW  10
00A4:  BCF    03.5
00A5:  XORWF  08,F
....................     }
....................     if(input_state(PIN_A3)==0){
00A6:  BTFSC  05.3
00A7:  GOTO   0AD
....................         output_toggle(PIN_D4);
00A8:  BSF    03.5
00A9:  BCF    08.4
00AA:  MOVLW  10
00AB:  BCF    03.5
00AC:  XORWF  08,F
....................     }
....................     if(input_state(PIN_A4)==0){
00AD:  BTFSC  05.4
00AE:  GOTO   0B4
....................         output_toggle(PIN_D4);
00AF:  BSF    03.5
00B0:  BCF    08.4
00B1:  MOVLW  10
00B2:  BCF    03.5
00B3:  XORWF  08,F
....................     }
00B4:  BCF    0B.1
00B5:  BCF    0A.3
00B6:  BCF    0A.4
00B7:  GOTO   035
.................... }
.................... 
.................... int timer1 = 0;
.................... #int_timer1
.................... void Ngat_Timer1(){
.................... //!   timer1++;
.................... //!   if(timer1 == 1){
.................... //!      timer1 = 0;
....................       if(input_state(PIN_B4)==1) {output_high(PIN_D0);}
00B8:  BTFSS  06.4
00B9:  GOTO   0BF
00BA:  BSF    03.5
00BB:  BCF    08.0
00BC:  BCF    03.5
00BD:  BSF    08.0
00BE:  GOTO   0C3
....................          else output_low(PIN_D0);
00BF:  BSF    03.5
00C0:  BCF    08.0
00C1:  BCF    03.5
00C2:  BCF    08.0
....................       if(input_state(PIN_B5)==1){output_high(PIN_D1);}
00C3:  BTFSS  06.5
00C4:  GOTO   0CA
00C5:  BSF    03.5
00C6:  BCF    08.1
00C7:  BCF    03.5
00C8:  BSF    08.1
00C9:  GOTO   0CE
....................          else output_low(PIN_D1);
00CA:  BSF    03.5
00CB:  BCF    08.1
00CC:  BCF    03.5
00CD:  BCF    08.1
....................       if(input_state(PIN_B6)==1) {output_high(PIN_D2);}
00CE:  BTFSS  06.6
00CF:  GOTO   0D5
00D0:  BSF    03.5
00D1:  BCF    08.2
00D2:  BCF    03.5
00D3:  BSF    08.2
00D4:  GOTO   0D9
....................          else output_low(PIN_D2);
00D5:  BSF    03.5
00D6:  BCF    08.2
00D7:  BCF    03.5
00D8:  BCF    08.2
....................       if(input_state(PIN_B7)==1) {output_high(PIN_D6);}
00D9:  BTFSS  06.7
00DA:  GOTO   0E0
00DB:  BSF    03.5
00DC:  BCF    08.6
00DD:  BCF    03.5
00DE:  BSF    08.6
00DF:  GOTO   0E4
....................          else output_low(PIN_D6);
00E0:  BSF    03.5
00E1:  BCF    08.6
00E2:  BCF    03.5
00E3:  BCF    08.6
.................... //!   }
00E4:  BCF    0C.0
00E5:  BCF    0A.3
00E6:  BCF    0A.4
00E7:  GOTO   035
.................... }
.................... 
.................... void main()
*
0315:  MOVF   03,W
0316:  ANDLW  1F
0317:  MOVWF  03
0318:  MOVLW  FF
0319:  MOVWF  2B
031A:  MOVLW  01
031B:  MOVWF  2F
031C:  MOVLW  08
031D:  MOVWF  30
031E:  CLRF   4A
031F:  CLRF   4C
0320:  CLRF   4B
0321:  BSF    03.5
0322:  BSF    1F.0
0323:  BSF    1F.1
0324:  BSF    1F.2
0325:  BCF    1F.3
0326:  MOVLW  07
0327:  MOVWF  1C
0328:  BCF    03.7
.................... {
....................    TRISB = 0xFF;        //PORTB CHANGE INTERRUPT
*
032B:  MOVLW  FF
032C:  BSF    03.5
032D:  MOVWF  06
....................    TRISD = 0x00;        //RD0 IS OUTPUT
032E:  CLRF   08
....................    PORTD = 0;           //OFF PIN D0
032F:  BCF    03.5
0330:  CLRF   08
....................     
....................    
....................    lcd_init(0x4E,16,2);
0331:  MOVLW  4E
0332:  MOVWF  4D
0333:  MOVLW  10
0334:  MOVWF  4E
0335:  MOVLW  02
0336:  MOVWF  4F
0337:  CALL   1EA
....................    lcd_backlight_led(ON);
0338:  MOVLW  01
0339:  MOVWF  4D
033A:  CALL   259
....................    lcd_init(0x40,16,2);
033B:  MOVLW  40
033C:  MOVWF  4D
033D:  MOVLW  10
033E:  MOVWF  4E
033F:  MOVLW  02
0340:  MOVWF  4F
0341:  CALL   1EA
....................    lcd_backlight_led(ON);
0342:  MOVLW  01
0343:  MOVWF  4D
0344:  CALL   259
.................... 
....................    lcd_putc('\f'); 
0345:  MOVLW  0C
0346:  MOVWF  50
0347:  CALL   298
....................    lcd_gotoxy(1,1); 
0348:  MOVLW  01
0349:  MOVWF  51
034A:  MOVWF  52
034B:  CALL   261
....................    printf(lcd_putc,"READING DHT11");
034C:  MOVLW  E8
034D:  BSF    03.6
034E:  MOVWF  0D
034F:  MOVLW  00
0350:  MOVWF  0F
0351:  BCF    03.6
0352:  GOTO   2BD
....................    delay_ms(500); 
0353:  MOVLW  02
0354:  MOVWF  4D
0355:  MOVLW  FA
0356:  MOVWF  51
0357:  CALL   0EF
0358:  DECFSZ 4D,F
0359:  GOTO   355
....................    lcd_putc('\f');
035A:  MOVLW  0C
035B:  MOVWF  50
035C:  CALL   298
.................... 
....................   
....................    //INTERRUPT SETTING
....................   CLEAR_INTERRUPT(INT_RB); 
035D:  MOVF   06,W
035E:  NOP
035F:  BCF    0B.0
.................... //!  ENABLE_INTERRUPTS(INT_RB);
....................   CLEAR_INTERRUPT(int_ext);
0360:  BCF    0B.1
....................   enable_interrupts(int_ext) ; // cho phep ngat ngoai
0361:  BSF    0B.4
....................   ext_int_edge(h_to_l) ; //chon canh kich ngat la tu cao xuong thap
0362:  BSF    03.5
0363:  BCF    01.6
....................   enable_interrupts (global);
0364:  MOVLW  C0
0365:  BCF    03.5
0366:  IORWF  0B,F
....................   
....................   enable_interrupts(int_timer1);
0367:  BSF    03.5
0368:  BSF    0C.0
....................   setup_timer_1(t1_internal|T1_DIV_BY_8); 
0369:  MOVLW  B5
036A:  BCF    03.5
036B:  MOVWF  10
....................   set_timer1(0);
036C:  CLRF   0E
036D:  CLRF   0F
036E:  CLRF   0E
036F:  NOP
....................   
....................    while(TRUE)
....................    {
0370:  GOTO   370
....................       //TODO: User Code
.................... //!      if (DHT_GetTemHumi(dh_nhiet_do,dh_nhiet_do2,dh_do_am,dh_do_am2))
.................... //!      { 
.................... //!         sprintf(str,"DO Am: %u,%u",dh_do_am,dh_do_am2);
.................... //!         lcd_gotoxy(1,1); 
.................... //!         printf(lcd_putc,"%s",str); 
.................... //!         lcd_putc('%'); 
.................... //!         sprintf(str,"NHIET D0: %u,%u",dh_nhiet_do,dh_nhiet_do2);
.................... //!         lcd_gotoxy(1,2); 
.................... //!         printf(lcd_putc,"%s",str); 
.................... //!         lcd_putc(223); 
.................... //!         lcd_putc('C'); 
.................... //!      } 
....................    }
.................... 
.................... }
0371:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
