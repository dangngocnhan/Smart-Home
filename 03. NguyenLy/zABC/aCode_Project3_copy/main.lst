CCS PCM C Compiler, Version 5.101, 43599               14-Nov-22 16:41

               Filename:   C:\Users\DangNgocNhan\Desktop\Project3\Code_Project3\main.lst

               ROM used:   286 words (3%)
                           Largest free fragment is 2048
               RAM used:   48 (13%) at main() level
                           59 (16%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   0D1
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.3
0018:  GOTO   01B
0019:  BTFSC  0B.0
001A:  GOTO   036
001B:  BTFSS  0B.4
001C:  GOTO   01F
001D:  BTFSC  0B.1
001E:  GOTO   039
001F:  MOVLW  8C
0020:  MOVWF  04
0021:  BTFSS  00.0
0022:  GOTO   025
0023:  BTFSC  0C.0
0024:  GOTO   03C
0025:  MOVF   22,W
0026:  MOVWF  04
0027:  MOVF   23,W
0028:  MOVWF  77
0029:  MOVF   24,W
002A:  MOVWF  78
002B:  MOVF   25,W
002C:  MOVWF  79
002D:  MOVF   26,W
002E:  MOVWF  7A
002F:  MOVF   20,W
0030:  MOVWF  0A
0031:  SWAPF  21,W
0032:  MOVWF  03
0033:  SWAPF  7F,F
0034:  SWAPF  7F,W
0035:  RETFIE
0036:  BCF    0A.3
0037:  BCF    0A.4
0038:  GOTO   03F
0039:  BCF    0A.3
003A:  BCF    0A.4
003B:  GOTO   065
003C:  BCF    0A.3
003D:  BCF    0A.4
003E:  GOTO   07E
.................... #include <main.h>
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
.................... 
.................... #list
.................... 
.................... 
.................... #device *=16 adc=8
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... #FUSES HS
.................... #use delay(crystal=20000000)
.................... #include <def_877a.h>
.................... #define W 0
.................... #define F 1
.................... 
.................... //----- Register Files------------------------------------------------------
.................... 
.................... #byte INDF =0x00
.................... #byte TMR0 =0x01 
.................... #byte PCL =0x02 
.................... #byte STATUS =0x03 
.................... #byte FSR =0x04 
.................... #byte PORTA =0x05 
.................... #byte PORTB =0x06 
.................... #byte PORTC =0x07
.................... #byte PORTD =0x08
.................... 
.................... 
.................... #byte PCLATH =0x0A 
.................... #byte PIR1 =0x0C
.................... #byte PIR2 =0x0D
.................... 
.................... #byte TMR1L =0x0E
.................... #byte TMR1H =0x0F
.................... #byte T1CON =0x10
.................... #byte TMR2 =0x11
.................... #byte T2CON =0x12
.................... 
.................... #byte SSPCON =0x14
.................... #byte CCPR1L =0x15
.................... #byte CCPR1H =0x16
.................... #byte CCP1CON =0x17
.................... #byte RCSTA =0x18
.................... #byte TXREG =0x19
.................... #byte RCREG =0x1A
.................... #byte CCPR2L =0x1B
.................... #byte CCPR2H =0x1C
.................... #byte CCP2CON =0x1D 
.................... 
.................... #byte ADRESH =0x1E
.................... #byte ADCON0 =0x1F
.................... 
.................... /* bank 1 registers */
.................... 
.................... #byte OPTION_REG =0x81
.................... 
.................... #byte TRISA =0x85
.................... #byte TRISB =0x86
.................... #byte TRISC =0x87
.................... #byte TRISD =0x88
.................... 
.................... #byte PIE1 =0x8C
.................... #byte PIE2 =0x8D
.................... #byte PCON =0x8E
.................... 
.................... #byte SSPCON2 =0x91
.................... #byte PR2 =0x92
.................... #byte SSPADD =0x93
.................... #byte SSPSTAT =0x94
.................... 
.................... #byte TXSTA =0x98
.................... #byte SPBRG =0x99
.................... 
.................... #byte ADRESL =0x9E
.................... #byte ADCON1 =0x9F
.................... 
.................... /* bank 2 registers */
.................... 
.................... #byte EEDATA =0x010C
.................... #byte EEADR =0x010D
.................... #byte EEDATH =0x010E
.................... #byte EEADRH =0x010F
.................... 
.................... /* bank 3 registers */
.................... 
.................... #byte EECON1 =0x018C
.................... #byte EECON2 =0x018D
.................... 
.................... 
.................... //----- STATUS Bits --------------------------------------------------------
.................... 
.................... // For Assembly Language - Note upper case
.................... #define IRP 7
.................... #define RP1 6
.................... #define RP0 5
.................... #define NOT_TO 4
.................... #define NOT_PD 3
.................... #define Z 2
.................... #define DC 1
.................... #define C 0
.................... 
.................... //----- INTCON Bits for c --------------------------------------------------------
.................... 
.................... #bit gie = 0x0b.7
.................... #bit eeie = 0x0b.6
.................... #bit t0ie = 0x0b.5
.................... #bit inte = 0x0b.4
.................... #bit rbie = 0x0b.3
.................... #bit t0if = 0x0b.2
.................... #bit intf = 0x0b.1
.................... #bit rbif = 0x0b.0
.................... 
.................... //---------PORTA bits------------------
.................... #bit ra5 =0x05.5
.................... #bit ra4 =0x05.4
.................... #bit ra3 =0x05.3
.................... #bit ra2 =0x05.2
.................... #bit ra1 =0x05.1
.................... #bit ra0 =0x05.0
.................... 
.................... //---------PORTB bits------------------
.................... #bit rb7 =0x06.7
.................... #bit rb6 =0x06.6
.................... #bit rb5 =0x06.5
.................... #bit rb4 =0x06.4
.................... #bit rb3 =0x06.3
.................... #bit rb2 =0x06.2
.................... #bit rb1 =0x06.1
.................... #bit rb0 =0x06.0
.................... 
.................... //---------PORTC bits------------------
.................... #bit rc7 =0x07.7
.................... #bit rc6 =0x07.6
.................... #bit rc5 =0x07.5
.................... #bit rc4 =0x07.4
.................... #bit rc3 =0x07.3
.................... #bit rc2 =0x07.2
.................... #bit rc1 =0x07.1
.................... #bit rc0 =0x07.0
.................... 
.................... #bit rd7 =0x08.7
.................... #bit rd6 =0x08.6
.................... #bit rd5 =0x08.5
.................... #bit rd4 =0x08.4
.................... #bit rd3 =0x08.3
.................... #bit rd2 =0x08.2
.................... #bit rd1 =0x08.1
.................... #bit rd0 =0x08.0
.................... 
.................... //----- PIR1 Bits ----------------------------------------------------------
.................... #bit PSPIF =0x0C.7
.................... #bit ADIF =0x0C.6
.................... #bit RCIF =0x0C.5
.................... #bit TXIF =0x0C.4
.................... #bit SSPIF =0x0C.3
.................... #bit CCP1IF =0x0C.2
.................... #bit TMR2IF =0x0C.1
.................... #bit TMR1IF =0x0C.0
.................... 
.................... //----- PIR2 Bits ----------------------------------------------------------
.................... #bit CMIF =0x0D.6
.................... #bit EEIF =0x0D.4
.................... #bit BCLIF =0x0D.3
.................... #bit CCP2IF =0x0D.0
.................... 
.................... //----- T1CON Bits ---------------------------------------------------------
.................... #bit T1CKPS1 =0x10.5
.................... #bit T1CKPS0 =0x10.4
.................... #bit T1OSCEN =0x10.3
.................... #bit T1SYNC =0x10.2
.................... #bit TMR1CS =0x10.1
.................... #bit TMR1ON =0x10.0
.................... 
.................... //----- T2CON Bits ---------------------------------------------------------
.................... #bit TOUTPS3 =0x12.6
.................... #bit TOUTPS2 =0x12.5
.................... #bit TOUTPS1 =0x12.4
.................... #bit TOUTPS0 =0x12.3
.................... #bit TMR2ON =0x12.2
.................... #bit T2CKPS1 =0x12.1
.................... #bit T2CKPS0 =0x12.0
.................... 
.................... //-------------SSPCON bits--------------------------
.................... #bit WCOL =0x14.7
.................... #bit SSPOV =0x14.6
.................... #bit SSPEN =0x14.5 
.................... #bit CKP =0x14.4
.................... #bit SSPM3 =0x14.3
.................... #bit SSPM2 =0x14.2
.................... #bit SSPM1 =0x14.1
.................... #bit SSPM0 =0x14.0
.................... 
.................... //---------------CCP1CON bits--------
.................... #bit CCP1X =0x17.5
.................... #bit CCP1Y =0x17.4
.................... #bit CCP1M3 =0x17.3
.................... #bit CCP1M2 =0x17.2
.................... #bit CCP1M1 =0x17.1
.................... #bit CCP1M0 =0x17.0
.................... 
.................... //---------------RCSTA bits-------------------
.................... 
.................... #bit SPEN =0x18.7
.................... #bit RX9 =0x18.6
.................... #bit SREN =0x18.5
.................... #bit CREN =0x18.4
.................... #bit ADDEN =0x18.3
.................... #bit FERR =0x18.2
.................... #bit OERR =0x18.1
.................... #bit RX9D =0x18.0
.................... 
.................... //-----------------------CCP2CON bits----------
.................... 
.................... #bit CCP2X =0x1D.5
.................... #bit CCP2Y =0x1D.4
.................... #bit CCP2M3 =0x1D.3
.................... #bit CCP2M2 =0x1D.2
.................... #bit CCP2M1 =0x1D.1
.................... #bit CCP2M0 =0x1D.0
.................... 
.................... //----- ADCON0 Bits --------------------------------------------------------
.................... #bit ADCS1 =0x1F.7
.................... #bit ADCS0 =0x1F.6
.................... #bit CHS2 =0x1F.5 
.................... #bit CHS1 =0x1F.4
.................... #bit CHS0 =0x1F.3
.................... #bit ADGO =0x1F.2
.................... #bit ADON =0x1F.0
.................... 
.................... //----- OPTION_reg Bits --------------------------------------------------------
.................... 
.................... #bit RBPU =0x81.7 
.................... #bit INTEDG =0x81.6 
.................... #bit T0CS =0x81.5 
.................... #bit T0SE =0x81.4 
.................... #bit PSA =0x81.3 
.................... #bit PS2 =0x81.2 
.................... #bit PS1 =0x81.1 
.................... #bit PS0 =0x81.0 
.................... 
.................... //------------------TRISA bits---------------------------
.................... 
.................... #bit TRISA5 =0x85.5
.................... #bit TRISA4 =0x85.4
.................... #bit TRISA3 =0x85.3
.................... #bit TRISA2 =0x85.2
.................... #bit TRISA1 =0x85.1 
.................... #bit TRISA0 =0x85.0
.................... 
.................... //-----------------TRISB bits-----------------------------
.................... 
.................... #bit TRISB7 =0x86.7
.................... #bit TRISB6 =0x86.6 
.................... #bit TRISB5 =0x86.5
.................... #bit TRISB4 =0x86.4 
.................... #bit TRISB3 =0x86.3
.................... #bit TRISB2 =0x86.2
.................... #bit TRISB1 =0x86.1 
.................... #bit TRISB0 =0x86.0 
.................... 
.................... //----------------TRISC bits-------------------
.................... 
.................... #bit TRISC7 =0x87.7
.................... #bit TRISC6 =0x87.6
.................... #bit TRISC5 =0x87.5 
.................... #bit TRISC4 =0x87.4
.................... #bit TRISC3 =0x87.3
.................... #bit TRISC2 =0x87.2 
.................... #bit TRISC1 =0x87.1
.................... #bit TRISC0 =0x87.0
.................... 
.................... #bit TRISD7 =0x88.7
.................... #bit TRISD6 =0x88.6
.................... #bit TRISD5 =0x88.5 
.................... #bit TRISD4 =0x88.4
.................... #bit TRISD3 =0x88.3
.................... #bit TRISD2 =0x88.2 
.................... #bit TRISD1 =0x88.1
.................... #bit TRISD0 =0x88.0
.................... 
.................... //----- PIE1 Bits ----------------------------------------------------------
.................... 
.................... #bit PSPIE =0x8C.7
.................... #bit ADIE =0x8C.6
.................... #bit RCIE =0x8C.5 
.................... #bit TXIE =0x8C.4 
.................... #bit SSPIE =0x8C.3
.................... #bit CCP1IE =0x8C.2 
.................... #bit TMR2IE =0x8C.1
.................... #bit TMR1IE =0x8C.0
.................... 
.................... //----- PIE2 Bits -----------------------------------------------------
.................... 
.................... #bit CMIE =0x8D.6
.................... #bit EEIE =0x8D.4
.................... #bit BCLIE =0x8D.3
.................... #bit CCP2IE =0x8D.0
.................... 
.................... //----- PCON Bits ----------------------------------------------------------
.................... 
.................... #bit POR =0x8E.1
.................... #bit BOD =0x8E.0
.................... 
.................... //-----------SSPCON2 bits---------------------------------------------
.................... 
.................... #bit GCEN =0x91.7
.................... #bit ACKSTAT =0x91.6
.................... #bit ACKDT =0x91.5 
.................... #bit ACKEN =0x91.4
.................... #bit RCEN =0x91.3 
.................... #bit PEN =0x91.2
.................... #bit RSEN =0x91.1
.................... #bit SEN =0x91.0 
.................... 
.................... //---------------------SSPSTAT bits------------------------
.................... 
.................... #bit STAT_SMP =0x94.7
.................... #bit STAT_CKE =0x94.6
.................... #bit STAT_DA =0x94.5
.................... #bit STAT_P =0x94.4
.................... #bit STAT_S =0x94.3
.................... #bit STAT_RW =0x94.2
.................... #bit STAT_UA =0x94.1
.................... #bit STAT_BF =0x94.0
.................... 
.................... //----------------TXSTA bits-----------------
.................... 
.................... #bit CSRC =0x98.7
.................... #bit TX9 =0x98.6
.................... #bit TXEN =0x98.5 
.................... #bit SYNC =0x98.4
.................... #bit BRGH =0x98.2
.................... #bit TRMT =0x98.1
.................... #bit TX9D =0x98.0
.................... 
.................... //--------------ADCON1 bits---------------
.................... 
.................... #bit ADFM =0x9F.7
.................... #bit ADCS2 =0x9F.6
.................... #bit PCFG3 =0x9F.3
.................... #bit PCFG2 =0x9F.2
.................... #bit PCFG1 =0x9F.1 
.................... #bit PCFG0 =0x9F.0
.................... 
.................... //-----------EECON1 bits----------
.................... 
.................... #bit EEPGD =0x018C.7
.................... #bit WRERR =0x018C.3
.................... #bit WREN =0x018C.2 
.................... #bit WR =0x018C.1
.................... #bit RD =0x018C.0
.................... 
.................... //!const unsigned char Code7Seg_duong[] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
.................... //!const unsigned char Code7Seg_am[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0xFF};
.................... 
.................... 
.................... #use FIXED_IO( C_outputs=PIN_C2,PIN_C1,PIN_C0 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0)
.................... #define DHT11        PIN_A0
.................... #define CB_Mua       PIN_A1
.................... #define CB_KhiGa     PIN_A2
.................... #define CB_BaoChay   PIN_A3
.................... #define N_VeSinh     PIN_A4
.................... #define N_O_Bep      PIN_A5
.................... #define NgatNgoai    PIN_B0
.................... #define CamBien1     PIN_B1
.................... #define CamBien2     PIN_B2
.................... //!#define RB3          PIN_B3
.................... #define TangT        PIN_B4
.................... #define GiamT        PIN_B5
.................... #define BaoDong      PIN_B6
.................... #define Start_Stop   PIN_B7
.................... //!#define RC0          PIN_C0
.................... //!#define RC1          PIN_C1
.................... //!#define RC2          PIN_C2
.................... //!#define LCD1         PIN_C3
.................... //!#define LCD2         PIN_C4
.................... //!#define RC5          PIN_C5
.................... #define TX           PIN_C6
.................... #define RX           PIN_C7
.................... #define DenKhach     PIN_D0
.................... #define QuatKhach    PIN_D1
.................... #define QuatBep      PIN_D2
.................... #define DenBep       PIN_D3
.................... #define BaoDong1     PIN_D4
.................... #define BaoDong2     PIN_D5
.................... #define DenVeSinh    PIN_D6
.................... 
.................... 
.................... 
.................... //!#use rs232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7)
.................... //!
.................... #use i2c(Master,Fast=400000, sda=PIN_C4, scl=PIN_C3,force_sw)
.................... #include "i2c_Flex_LCD.c"
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 rows by 1...20 columns 
.................... //                using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.1 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 
.................... //                "20X4_LCD_I2C_DRIVER.h" from Pumrin S. and "lcd4_i2c.c" from XP8100 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD display 
.................... //     \n Set write position on next lcd line 
.................... //     \b LCD backspace 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... // lcd_backlight_led(ON)/lcd_backlight_led(OFF) = Turn ON/OFF LCD Backlight LED 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Comment   : Control of a compatible LCD (1...4 rows by 1...4 columns) from 
.................... //              a bus I2C with an EXPANDER of I/O with connection I2C. 
.................... //              The tests of these routines have been programmed using the IC 
.................... //              Phillips PCF8574T. I've used 4 bits mode programming. 
.................... //              The 8 bits mode programming is possible if you use 2 x PCF8574T. 
.................... //              RW Pin is not being used. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW    (Not used!) 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... byte LCD_ADDR ;//             0x4E        //I2C slave address for LCD module 
.................... byte lcd_total_rows ;//       2           //Number of rows: 1,2,3 or 4 
.................... byte lcd_total_columns ;//    16          //Number of columns: 1...20   
.................... 
.................... #define RS                    0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW                    0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define ENABLE                0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define LCD_BACKLIGHT         0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
.................... 
.................... #define addr_row_one          0x00        //LCD RAM address for row 1 
.................... #define addr_row_two          0x40        //LCD RAM address for row 2 
.................... #define addr_row_three        0x14        //LCD RAM address for row 3 
.................... #define addr_row_four         0x54        //LCD RAM address for row 4 
.................... 
.................... #define ON                    1 
.................... #define OFF                   0 
.................... #define NOT                   ~ 
.................... #define data_shifted          data<<4 
.................... int8 new_row_request=1, BACKLIGHT_LED=LCD_BACKLIGHT; 
.................... 
.................... void lcd_backlight_led(byte bl) 
.................... {  
....................       If (bl) BACKLIGHT_LED=LCD_BACKLIGHT; else BACKLIGHT_LED=OFF; 
.................... } 
.................... 
.................... void i2c_send_nibble(byte data, byte type) 
.................... {    
....................    switch (type) 
....................    {      
....................       case 0 :      
....................       i2c_write(data_shifted | BACKLIGHT_LED); 
....................       delay_cycles(1); 
....................       i2c_write(data_shifted | ENABLE | BACKLIGHT_LED ); 
....................       delay_us(2); 
....................       i2c_write(data_shifted & NOT ENABLE | BACKLIGHT_LED); 
....................       break; 
....................       
....................       case 1 : 
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED); 
....................       delay_cycles(1); 
....................       i2c_write(data_shifted | RS | ENABLE | BACKLIGHT_LED ); 
....................       delay_us(2); 
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED); 
....................       break; 
....................    } 
.................... } 
....................     
.................... void lcd_send_byte(byte data, byte type) 
....................    { 
....................         i2c_start(); 
....................         i2c_write(LCD_ADDR); 
....................         i2c_send_nibble(data >> 4 , type); 
....................         i2c_send_nibble(data & 0xf , type); 
....................         i2c_stop();        
....................    } 
.................... 
.................... void lcd_clear() 
.................... {  
....................         lcd_send_byte(0x01,0); 
....................         delay_ms(2); 
....................         new_row_request=1; 
.................... } 
.................... 
.................... void lcd_init(byte ADDR, byte col, byte row) 
.................... { 
....................    byte i;
....................    byte CONST lcd_type=2;  // 0=5x7, 1=5x10, 2=2 lines 
....................    byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; // These bytes need to be sent to the LCD to start it up.
....................    
....................    LCD_ADDR =ADDR;//             0x4E        //I2C slave address for LCD module 
....................    lcd_total_rows =row;//       2           //Number of rows: 1,2,3 or 4 
....................    lcd_total_columns= col ;
....................    disable_interrupts(GLOBAL); 
....................    delay_ms(50); //LCD power up delay 
....................     
....................    i2c_start(); 
....................    i2c_write(LCD_ADDR); 
....................       i2c_send_nibble(0x00,0); 
....................       delay_ms(15); 
....................     
....................    for (i=1;i<=3;++i)    
....................    { 
....................       i2c_send_nibble(0x03,0); 
....................       delay_ms(5); 
....................    }    
....................       i2c_send_nibble(0x02,0); 
....................       delay_ms(5); 
....................    i2c_stop(); 
....................     
....................    for (i=0;i<=3;++i) { 
....................    lcd_send_byte(LCD_INIT_STRING[i],0); 
....................    delay_ms(5); 
....................    } 
....................    lcd_clear();  //Clear Display 
....................    enable_interrupts(GLOBAL); 
.................... } 
.................... 
.................... void lcd_gotoxy( byte x, byte y) 
.................... { 
.................... byte row,column,row_addr,lcd_address; 
.................... static char data; 
*
00E9:  BCF    03.5
00EA:  CLRF   2C
.................... 
....................    if (y>lcd_total_rows) row=lcd_total_rows; else row=y; 
....................   
....................    switch(row) 
....................    { 
....................       case 1:  row_addr=addr_row_one;     break; 
....................       case 2:  row_addr=addr_row_two;     break; 
....................       case 3:  row_addr=addr_row_three;   break; 
....................       case 4:  row_addr=addr_row_four;    break; 
....................       default: row_addr=addr_row_one;     break;  
....................    }  
....................     
....................    if (x>lcd_total_columns) column=lcd_total_columns; else column=x;  
....................    lcd_address=(row_addr+(column-1)); 
....................    lcd_send_byte(0x80|lcd_address,0); 
.................... } 
.................... 
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... {    
....................   switch(in_data) 
....................    {  
....................      case '\f': lcd_clear();                       break;                
....................       
....................      case '\n': 
....................      new_row_request++; 
....................      if (new_row_request>lcd_total_rows) new_row_request=1; 
....................      lcd_gotoxy(1, new_row_request); 
....................      break; 
....................                   
....................      case '\b': lcd_send_byte(0x10,0);             break; 
....................         
....................      default: lcd_send_byte(in_data,1);            break;      
....................       
....................    } 
.................... } 
.................... 
.................... #include "DHT11.c"
.................... #define _DHT11_H_
.................... //!#include <def_877a.h>
.................... #use delay(crystal=20M)
.................... 
.................... #BIT DHT_DATA_OUT = 0x05.0
.................... #BIT DHT_DATA_IN = 0x05.0 
.................... #BIT DHT_DDR_DATA = 0x85.0
.................... 
.................... #define DHT_ER 0
.................... #define DHT_OK 1
.................... 
.................... #define DDROUT 0
.................... #define DDRIN 1
.................... 
.................... unsigned int8 DHT_GetTemHumi (unsigned int8 &tem1, , &tem2, unsigned int8 &humil, &humi2);
.................... 
.................... unsigned int8 DHT_GetTemHumi (unsigned int8 &tem1,&tem2, unsigned int8 &humi1, &humi2)
.................... { 
....................    unsigned int8 buffer[5]={0,0,0,0,0};
....................    unsigned int8 ii,i,checksum;
....................    DHT_DDR_DATA=DDROUT;    // set la cong ra
....................    DHT_DATA_OUT=1;
....................    delay_us(60);
....................    DHT_DATA_OUT=0;
....................    delay_ms(25); // it nhat 18ms
....................    DHT_DATA_OUT=1;
....................    DHT_DDR_DATA=DDRIN;//set la cong vao
....................    
....................    delay_us(60);
....................    if(DHT_DATA_IN) return DHT_ER;
....................    else while(!(DHT_DATA_IN)); //Doi DaTa len 1
....................    delay_us(60);//cho 60us
....................    if(!DHT_DATA_IN) return DHT_ER;
....................    else while((DHT_DATA_IN)); //Doi Data ve 0
....................     //Bat dau doc du lieu
....................     for(i=0;i<5;i++) 
....................     {
....................       for(ii=0;ii<8;ii++) 
....................       {
....................          while((!DHT_DATA_IN));              // Doi Data len 1
....................          delay_us(50);
....................          if(DHT_DATA_IN)
....................          {
....................             buffer[i]|=(1<<(7-ii));
....................             while((DHT_DATA_IN));
....................          }
....................       }
....................     }
....................    checksum=buffer[0]+buffer[1]+buffer[2]+buffer[3]; 
....................    if((checksum) !=buffer[4])return DHT_ER; 
....................    tem1 = buffer[2];//gia tri phan nguyen 
....................    tem2 = buffer[3];//gia tri phan thap phan
....................    humi1 = buffer[0];//gia tri phan nguyen 
....................    humi2 = buffer[1];//gia tri phan thap phan
....................    return DHT_OK;
.................... }
.................... 
.................... //!
.................... //!
.................... //!#include <def_877a.h>
.................... //!#bit ra0 =0x05.0
.................... //!#bit TRISA0 =0x85.0
.................... //!#device *=16 adc=8
.................... //!#define  Data_Pin       Pin_D4                      // ket noi voi chan RD0
.................... //!#define  Data_Pin_TRIS  SET_TRIS_D                // dieu khien chan data la output hay input 
.................... //!
.................... //!int8 Data_DHT11[5];
.................... //!
.................... //!int1 DHT11_Start(){    // start
.................... //!   Data_Pin_TRIS(0);   // MCU output
.................... //!   Output_low(Data_Pin);        // MCU keo chan data xuong muc thap >18 ms
.................... //!   delay_ms(25);
.................... //!   Output_high(Data_Pin);        // MCU keo chan data len muc cao 
.................... //!   Data_Pin_TRIS(0xff);   // MCU input doi tin hieu tra ve cua DHT11 khoang 20 - 40 us
.................... //!   delay_us(40);
.................... //!   if(input(Data_Pin) == 0){    //DHT11 keo chan data xuong thap 80 us sau do keo len cao 80 us --> xac nhan ket noi
.................... //!      delay_us(80);
.................... //!      if(input(Data_Pin) == 1){
.................... //!         delay_us(80);
.................... //!         return 1;         // xac nhan ket noi thanh cong
.................... //!      }
.................... //!   }
.................... //!}
.................... //! 
.................... //!
.................... //!int1 ReadData_DHT11(){       // doc data cua DHT11 tra ve
.................... //!    for(int i = 0; i < 5; i++){        // data: 5 byte
.................... //!      for(int j = 0; j < 8; j++){      // 1 byte 8 bit   tong 40 bit
.................... //!         // data
.................... //!         while(input(Data_Pin) == 0){};      // chay het 50us muc thap
.................... //!         delay_us(30);              //  hon 26-28us van la muc cao --> DHT11 chuyen di muc 1
.................... //!         if(input(Data_Pin) == 1){  
.................... //!               Data_DHT11[i] = Data_DHT11[i]<<1 | 1;
.................... //!               while(input(Data_Pin) == 1){} // chay het 70us muc cao
.................... //!         }
.................... //!         else{                   // tra ve bit 0
.................... //!            Data_DHT11[i] = Data_DHT11[i]<<1 | 0;
.................... //!         }
.................... //!      }   
.................... //!    }
.................... //!    // ------- kiem tra byte 5 = sum(byte 1 + 2 + 3 + 4) --> chuyen data thanh cong. nguoc lai 
.................... //!    if(Data_DHT11[4] == (Data_DHT11[0] + Data_DHT11[1] + Data_DHT11[2] + Data_DHT11[3])){
.................... //!      return 1;
.................... //!    }
.................... //!}
.................... //!
.................... //!
.................... //!
.................... //!
.................... //!void HienThi_Data_DHT11(){
.................... //!    //------------------in ket qua-----------------------------------------------
.................... //!    //in nhiet do
.................... //! 
.................... //!    
.................... //!    lcd_init(0x4E,16,2);
.................... //!    printf(lcd_putc, "Nhiet do = "); 
.................... //!    for(int i = 13; i > 11; i--){
.................... //!       lcd_gotoxy(i,1);       //hien thi hang don vi truoc >hang chuc
.................... //!       printf(lcd_putc, "%d", Data_DHT11[2] % 10 + 48); 
.................... //!       Data_DHT11[2]=Data_DHT11[2] / 10;
.................... //!    }
.................... //!    //in do am
.................... //!    lcd_gotoxy(1,2);
.................... //!    printf(lcd_putc, "Do am = ");  
.................... //!    for(int i = 13; i > 11; i--){ 
.................... //!       lcd_gotoxy(i,2);   
.................... //!       printf(lcd_putc, "%d", Data_DHT11[0] % 10 + 48); //hien thi hang don vi truoc >hang chuc  //doi ra so thap phan +48 
.................... //!       Data_DHT11[0]=Data_DHT11[0] / 10;
.................... //!    }
.................... //!      //hien thi don vi nhiet do va do am 
.................... //!    LCD_Gotoxy(14,1);   
.................... //!    LCD_putc(223);
.................... //!    LCD_putc('C');
.................... //!    LCD_Gotoxy(14,2);   
.................... //!    LCD_putc('%');
.................... //!}
.................... 
.................... 
.................... 
.................... // khai bao cac bien
.................... unsigned int8 kqUart;
.................... unsigned int8 dh_nhiet_do,dh_nhiet_do2,dh_do_am,dh_do_am2;   //cac bien luu tru nhiet do do am
.................... unsigned int8 str[20];
.................... int8 soNguoi = 0;
.................... int8 NhietDoDk_Bat = 25;
.................... int8 NhietDoDk_Tat = 20;
.................... int start_stop_b = 0;
.................... int1 baodong_b = 0, checkDenKhach = 1, checkQuatKhach = 1;
.................... 
.................... 
.................... //!#INT_RDA
.................... //!void uart_(){
.................... //!   kqUart = getc();
.................... //!   switch(kqUart){
.................... //!      case '1':
.................... //!         checkDenKhach = 1;
.................... //!         break;
.................... //!      case '2':
.................... //!         checkDenKhach = 0;
.................... //!         break;
.................... //!   }
.................... //!}
.................... 
.................... void check_Den_Khach(){
....................    if(soNguoi > 0 && checkDenKhach){
*
00BE:  MOVF   46,F
00BF:  BTFSC  03.2
00C0:  GOTO   0C9
00C1:  BTFSS  4A.1
00C2:  GOTO   0C9
....................       output_high(DenKhach);
00C3:  MOVLW  00
00C4:  BSF    03.5
00C5:  MOVWF  08
00C6:  BCF    03.5
00C7:  BSF    08.0
....................       //lcd; gui data
.................... //!      putc('1');
....................    }
00C8:  GOTO   0CE
....................    else {
....................       output_low(Denkhach);
00C9:  MOVLW  00
00CA:  BSF    03.5
00CB:  MOVWF  08
00CC:  BCF    03.5
00CD:  BCF    08.0
....................       //lcd; gui data
.................... //!      putc('2');
....................    }
00CE:  BCF    0A.3
00CF:  BCF    0A.4
00D0:  GOTO   11C (RETURN)
.................... }
.................... 
.................... int1 checkQuatKhachDHT11(){
....................    if(NhietDoDk_Bat <= dh_nhiet_do){
....................       return 1;
....................    }
....................    if(NhietDoDk_Tat >= dh_nhiet_do){
....................       return 0;   
....................    }
.................... }
.................... 
.................... void check_Quat_Khach(){
....................    if(soNguoi > 0 && checkQuatKhach && checkQuatKhachDHT11()){
....................       output_high(QuatKhach);
....................       // LCD; gui data
.................... //!      putc('A');
....................    }
....................    else{
....................       output_low(QuatKhach);
....................       //LCD; gui data
.................... //!      putc('B');
....................    }
.................... }
.................... 
.................... 
.................... #INT_RB
.................... void portb_interrupt(void)
.................... {
....................    CLEAR_INTERRUPT(INT_RB);    //clear flag interrupt
*
003F:  MOVF   06,W
0040:  NOP
0041:  BCF    0B.0
....................    if(input_state(Start_Stop)==0) { 
0042:  BTFSC  06.7
0043:  GOTO   049
....................       start_stop_b++;
0044:  INCF   49,F
....................       if(start_stop_b > 2 ){start_stop_b = 0;}
0045:  MOVF   49,W
0046:  SUBLW  02
0047:  BTFSS  03.0
0048:  CLRF   49
....................    }
....................    if(input_state(TangT)==0) {
0049:  BTFSC  06.4
004A:  GOTO   053
....................       if(start_stop_b == 1){
004B:  DECFSZ 49,W
004C:  GOTO   04F
....................          NhietDoDk_Bat++;
004D:  INCF   47,F
....................       }else if(start_stop_b == 2){
004E:  GOTO   053
004F:  MOVF   49,W
0050:  SUBLW  02
0051:  BTFSC  03.2
....................          NhietDoDk_Tat++;
0052:  INCF   48,F
....................       }
....................    }
....................    if(input_state(GiamT)==0) {
0053:  BTFSC  06.5
0054:  GOTO   05D
....................       if(start_stop_b == 1){
0055:  DECFSZ 49,W
0056:  GOTO   059
....................          NhietDoDk_Bat--;
0057:  DECF   47,F
....................       }else if(start_stop_b == 2){
0058:  GOTO   05D
0059:  MOVF   49,W
005A:  SUBLW  02
005B:  BTFSC  03.2
....................          NhietDoDk_Tat--;
005C:  DECF   48,F
....................       }
....................    }
....................    if(input_state(BaoDong)==0) {
005D:  BTFSC  06.6
005E:  GOTO   061
....................       baodong_b=~baodong_b;
005F:  MOVLW  01
0060:  XORWF  4A,F
....................    }
.................... }
.................... 
.................... 
0061:  BCF    0B.0
0062:  BCF    0A.3
0063:  BCF    0A.4
0064:  GOTO   025
.................... #int_ext // giup vao ngat
.................... void Ngat_int_ext()
.................... {
....................     CLEAR_INTERRUPT(int_ext);
0065:  BCF    0B.1
....................     if(input_state(CamBien1)==0){
0066:  BTFSC  06.1
0067:  GOTO   06D
....................       disable_interrupts(int_ext); 
0068:  BCF    0B.4
....................       while(input_state(CamBien2));
0069:  BTFSC  06.2
006A:  GOTO   069
....................       soNguoi++;
006B:  INCF   46,F
....................     }else{
006C:  GOTO   079
....................       if(input_state(CamBien2)==0){
006D:  BTFSC  06.2
006E:  GOTO   079
....................          disable_interrupts(int_ext);
006F:  BCF    0B.4
....................          while(input_state(CamBien1));
0070:  BTFSC  06.1
0071:  GOTO   070
....................          if(soNguoi <= 1) soNguoi = 0;
0072:  MOVF   46,W
0073:  SUBLW  01
0074:  BTFSS  03.0
0075:  GOTO   078
0076:  CLRF   46
0077:  GOTO   079
....................          else soNguoi--;   
0078:  DECF   46,F
....................       }
....................    }
....................    enable_interrupts(int_ext);
0079:  BSF    0B.4
.................... }
.................... 
.................... //!int timer1 = 0;
007A:  BCF    0B.1
007B:  BCF    0A.3
007C:  BCF    0A.4
007D:  GOTO   025
.................... #int_timer1
.................... void Ngat_Timer1(){
....................    if(input_state(CB_KhiGa)==1) {output_high(QuatBep); output_high(BaoDong2);}
007E:  BTFSS  05.2
007F:  GOTO   08A
0080:  MOVLW  00
0081:  BSF    03.5
0082:  MOVWF  08
0083:  BCF    03.5
0084:  BSF    08.2
0085:  BSF    03.5
0086:  MOVWF  08
0087:  BCF    03.5
0088:  BSF    08.5
0089:  GOTO   093
....................       else { output_low(QuatBep); output_low(BaoDong2); }
008A:  MOVLW  00
008B:  BSF    03.5
008C:  MOVWF  08
008D:  BCF    03.5
008E:  BCF    08.2
008F:  BSF    03.5
0090:  MOVWF  08
0091:  BCF    03.5
0092:  BCF    08.5
....................    if(input_state(CB_BaoChay)==1){output_high(BaoDong2);}
0093:  BTFSS  05.3
0094:  GOTO   09B
0095:  MOVLW  00
0096:  BSF    03.5
0097:  MOVWF  08
0098:  BCF    03.5
0099:  BSF    08.5
009A:  GOTO   0A0
....................       else output_low(BaoDong2);
009B:  MOVLW  00
009C:  BSF    03.5
009D:  MOVWF  08
009E:  BCF    03.5
009F:  BCF    08.5
....................    if(input_state(N_VeSinh)==1) {output_high(DenVeSinh);}
00A0:  BTFSS  05.4
00A1:  GOTO   0A8
00A2:  MOVLW  00
00A3:  BSF    03.5
00A4:  MOVWF  08
00A5:  BCF    03.5
00A6:  BSF    08.6
00A7:  GOTO   0AD
....................       else output_low(DenVeSinh);
00A8:  MOVLW  00
00A9:  BSF    03.5
00AA:  MOVWF  08
00AB:  BCF    03.5
00AC:  BCF    08.6
....................    if(input_state(N_O_Bep)==1) {output_high(DenBep);}
00AD:  BTFSS  05.5
00AE:  GOTO   0B5
00AF:  MOVLW  00
00B0:  BSF    03.5
00B1:  MOVWF  08
00B2:  BCF    03.5
00B3:  BSF    08.3
00B4:  GOTO   0BA
....................       else output_low(DenBep);
00B5:  MOVLW  00
00B6:  BSF    03.5
00B7:  MOVWF  08
00B8:  BCF    03.5
00B9:  BCF    08.3
00BA:  BCF    0C.0
00BB:  BCF    0A.3
00BC:  BCF    0A.4
00BD:  GOTO   025
.................... }
.................... 
.................... 
.................... 
.................... void main()
*
00D1:  MOVF   03,W
00D2:  ANDLW  1F
00D3:  MOVWF  03
00D4:  MOVLW  01
00D5:  MOVWF  2A
00D6:  MOVLW  08
00D7:  MOVWF  2B
00D8:  CLRF   46
00D9:  MOVLW  19
00DA:  MOVWF  47
00DB:  MOVLW  14
00DC:  MOVWF  48
00DD:  CLRF   49
00DE:  BCF    4A.0
00DF:  BSF    4A.1
00E0:  BSF    4A.2
00E1:  BSF    03.5
00E2:  BSF    1F.0
00E3:  BSF    1F.1
00E4:  BSF    1F.2
00E5:  BCF    1F.3
00E6:  MOVLW  07
00E7:  MOVWF  1C
00E8:  BCF    03.7
.................... {
....................    TRISB = 0xFF;        //PORTB CHANGE INTERRUPT
*
00EB:  MOVLW  FF
00EC:  BSF    03.5
00ED:  MOVWF  06
....................    TRISD = 0x00;        //RD0 IS OUTPUT
00EE:  CLRF   08
....................    PORTD = 0;           //OFF PIN D0
00EF:  BCF    03.5
00F0:  CLRF   08
....................    TRISA1 = 1;TRISA2 = 1;TRISA3 = 1;TRISA4 = 1;TRISA5 = 1;
00F1:  BSF    03.5
00F2:  BSF    05.1
00F3:  BSF    05.2
00F4:  BSF    05.3
00F5:  BSF    05.4
00F6:  BSF    05.5
....................     
....................    
.................... //!   lcd_init(0x4E,16,2);
.................... //!   lcd_backlight_led(ON);
.................... //!   lcd_init(0x40,16,2);
.................... //!   lcd_backlight_led(ON);
.................... //!
.................... //!   lcd_putc('\f'); 
.................... //!   lcd_gotoxy(1,1); 
.................... //!   printf(lcd_putc,"READING DHT11");
.................... //!   delay_ms(500); 
.................... //!   lcd_putc('\f');
.................... 
....................   
....................    //INTERRUPT SETTING
....................   enable_interrupts(INT_RDA);
00F7:  BSF    0C.5
....................    
....................   CLEAR_INTERRUPT(INT_RB); 
00F8:  BCF    03.5
00F9:  MOVF   06,W
00FA:  NOP
00FB:  BCF    0B.0
....................   ENABLE_INTERRUPTS(INT_RB);
00FC:  BSF    0B.3
....................   
....................   CLEAR_INTERRUPT(int_ext);
00FD:  BCF    0B.1
....................   enable_interrupts(int_ext); // cho phep ngat ngoai
00FE:  BSF    0B.4
....................   ext_int_edge(h_to_l) ; //chon canh kich ngat la tu cao xuong thap
00FF:  BSF    03.5
0100:  BCF    01.6
....................   enable_interrupts (global);
0101:  MOVLW  C0
0102:  BCF    03.5
0103:  IORWF  0B,F
....................   
....................   enable_interrupts(int_timer1);
0104:  BSF    03.5
0105:  BSF    0C.0
....................   setup_timer_1(t1_internal|T1_DIV_BY_8); 
0106:  MOVLW  B5
0107:  BCF    03.5
0108:  MOVWF  10
....................   set_timer1(0);
0109:  CLRF   0E
010A:  CLRF   0F
010B:  CLRF   0E
010C:  NOP
....................   
....................    while(TRUE)
....................    {
....................       //TODO: User Code
.................... //!      if (DHT_GetTemHumi(dh_nhiet_do,dh_nhiet_do2,dh_do_am,dh_do_am2))
.................... //!      { 
.................... //!         sprintf(str,"DO Am: %u,%u",dh_do_am,dh_do_am2);
.................... //!         lcd_gotoxy(1,1); 
.................... //!         printf(lcd_putc,"%s",str); 
.................... //!         lcd_putc('%'); 
.................... //!         sprintf(str,"NHIET D0: %u,%u",dh_nhiet_do,dh_nhiet_do2);
.................... //!         lcd_gotoxy(1,2); 
.................... //!         printf(lcd_putc,"%s",str); 
.................... //!         lcd_putc(223); 
.................... //!         lcd_putc('C'); 
.................... //!      } 
.................... //!      sprintf(str,"DK: %u, %u, %u",start_stop_b,NhietDoDk_Bat,NhietDoDk_Tat);
.................... //!      lcd_gotoxy(1,1); 
.................... //!      printf(lcd_putc,"%s",str); 
.................... 
.................... //!      if(NhietDoDk_Bat > 25){
.................... //!         output_high(DenBep);
.................... //!      }else output_low(DenBep);
.................... //!      if(NhietDoDk_Tat < 20){
.................... //!         output_high(QuatBep);
.................... //!      }else output_low(QuatBep);
....................       
....................       if(soNguoi){
010D:  MOVF   46,F
010E:  BTFSC  03.2
010F:  GOTO   116
....................          output_high(DenKhach);
0110:  MOVLW  00
0111:  BSF    03.5
0112:  MOVWF  08
0113:  BCF    03.5
0114:  BSF    08.0
....................       }else output_low(DenKhach);
0115:  GOTO   11B
0116:  MOVLW  00
0117:  BSF    03.5
0118:  MOVWF  08
0119:  BCF    03.5
011A:  BCF    08.0
....................       check_Den_Khach();
011B:  GOTO   0BE
011C:  GOTO   10D
....................    }
.................... 
.................... }
.................... 
011D:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
